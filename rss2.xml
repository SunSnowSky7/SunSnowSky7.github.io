<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>冉冉的博客</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>逆风飞翔，展开翅膀</description>
    <pubDate>Thu, 01 Feb 2024 01:07:39 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>服务器最大支持的TCP连接数</title>
      <link>http://example.com/2024/02/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%80%E5%A4%A7%E6%94%AF%E6%8C%81%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%E6%95%B0/</link>
      <guid>http://example.com/2024/02/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%80%E5%A4%A7%E6%94%AF%E6%8C%81%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%E6%95%B0/</guid>
      <pubDate>Thu, 01 Feb 2024 01:03:12 GMT</pubDate>
      
      <description>&lt;p&gt;本章内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一个服务端进程最大能支持多少条 TCP 连接？&lt;/li&gt;
&lt;li&gt;一台服务器最大能支持多少条 TCP 连接？&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本章内容</p><blockquote><ul><li>一个服务端进程最大能支持多少条 TCP 连接？</li><li>一台服务器最大能支持多少条 TCP 连接？</li></ul></blockquote><span id="more"></span><p>很多同学第一反应就是端口的限制，端口号最多是 65536个，那就最多只能支持 65536 条 TCP 连接。</p><p>实际上这是不对的</p><p>今天都带大家分析一波这两个问题。</p><h1 id="一个服务端进程最多能支持多少条-TCP-连接？"><a href="#一个服务端进程最多能支持多少条-TCP-连接？" class="headerlink" title="一个服务端进程最多能支持多少条 TCP 连接？"></a>一个服务端进程最多能支持多少条 TCP 连接？</h1><p>首先我们要知道 TCP 连接本质上在内核里就是一个 socket 对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span>  </span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//INET域专用的一个socket表示, 提供了INET域专有的一些属性，比如 IP地址，端口等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>             *<span class="title">sk</span>;</span>  </span><br><span class="line">    <span class="comment">//TCP连接的状态：SYN_SENT、SYN_RECV、ESTABLISHED.....</span></span><br><span class="line">    <span class="type">short</span>                   type;  </span><br><span class="line">    ....</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> &#123;</span>  </span><br><span class="line">...</span><br><span class="line">  __u32    daddr;   <span class="comment">//IPv4的目标地址。  </span></span><br><span class="line">  __u16    dport;   <span class="comment">//目标端口。   </span></span><br><span class="line">  __u32    saddr;   <span class="comment">//源地址。  </span></span><br><span class="line">  __u16    sport;   <span class="comment">//源端口。  </span></span><br><span class="line">...</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>这个 socket 对象也就是一个数据结构，里面包含了 TCP 四元组的信息：源IP、源端口、目标IP、目标端口。</p><p><img src="image.png" alt="TCP_四元组"></p><p>所以， 只要确认了【源IP、源端口、目标IP、目标端口】这四个信息，就能在内核中找到这个 socket 对象，也就能确定一条 TCP 连接。</p><p>一个服务端进程通常是监听 1 个端口号（当然也可能监听多个端口号，这里不考虑），比如我的图解网站的 nginx 服务，就监听了 443 端口。</p><p><img src="image-1.png" alt="Alt text"><br>你们看图解网站的时候，实际上就是通过 nginx 服务把网页数据发送给你们的。</p><p>然后，服务端进程除了会固定监听某个一个端口之外，也通常会绑定 0.0.0.0 IP 地址。</p><p>这个IP地址是特殊的， 0.0.0.0 指的是本机上的所有IPV4地址，如果一个主机有两个 IP 地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0，那么通过两个 IP 地址都能够访问该服务。</p><p>所以一个服务端进程，意味着他的 IP地址和端口号是固定的（0.0.0.0:443）。</p><p>也就是当客户端与服务端建立一条 TCP 连接的时候，这个 TCP 连接的四元组信息中服务端的 IP地址和端口号是固定的，能产生变化的就是客户端的 IP 地址和端口号了。</p><p>因此，一个服务端进程最大能支持的 TCP 连接个数的计算公式如下：</p><p><img src="image-2.png" alt="Alt text"></p><p>对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方。</p><p>那么一个服务端进程理想情况下，最大的 TCP 连接数约为 2 的 48 次方（2^32 (ip数) * 2^16 (端口数），这数值是非常夸张的了，约等于两百多万亿！</p><p>当然，服务端进程最大能支持的 TCP 连接数远不能达到理论上限，还会受到文件描述符、内存大小资源的限制，毕竟 socket 在 Linux 的视角其实就是文件资源，而且一个 socket 对象也会占用一定的内存资源。</p><p>因此，会受以下因素影响：</p><blockquote><ul><li>文件描述符限制，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<blockquote><ul><li>系统级：当前系统可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 查看；</li><li>用户级：指定用户可打开的最大数量，通过 cat &#x2F;etc&#x2F;security&#x2F;limits.conf 查看；</li><li>进程级：单个进程可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;nr_open 查看；</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>内存限制，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li></ul></blockquote><h1 id="一台服务器最大最多能支持多少条-TCP-连接？"><a href="#一台服务器最大最多能支持多少条-TCP-连接？" class="headerlink" title="一台服务器最大最多能支持多少条 TCP 连接？"></a>一台服务器最大最多能支持多少条 TCP 连接？</h1><p>前面分析是一个服务端进程理的情况，理论上能最大支持约为 2 的 48 次方（2^32 (ip数) * 2^16 (端口数），约等于两百多万亿！</p><p>那到了一台服务器的视角就会有一点不一样。</p><p>一台服务器是可以有多个服务端进程的，每个服务端进程监听不同的端口，比如：ssh的22，Redis的6339，当然所有65535个端口你都可以用来监听一遍。<br><img src="image-3.png" alt="Alt text"><br>当然所有65535个端口你都可以用来监听一遍，这样理论上线就到了2的32次方（ip数）×2的16次方（port数）×2的16次方（服务器port数）个，感兴趣你可以算一下，这个基本相当于无穷个了。</p><p>不过理想和实际总是会有差距的！</p><p>因为Linux每维护一条TCP连接都要花费资源，处理连接请求，保活，数据的收发时需要消耗一些CPU，维持TCP连接主要消耗内存。</p><p>我们题目的问题是考虑最大多少个连接，所以我们先不考虑数据的收发，那么TCP在静止的状态下，就不怎么消耗CPU了，主要消耗内存，而Linux上内存是有限的。</p><p>首先，我们要知道一条处于 ESTABLISH 状态的 TCP 连接具体占用多大内存？</p><p><strong>一个 TCP 对象占用的大小，等于它所包含的一些数据结构占用大小的总和，也是就把上面这些数据结构的大小累加起来，就是一个 TCP 连接占用的大小了。</strong></p><p>这里直接给大家一个结论，<strong>一条处于 ESTABLISH 状态的 TCP 连接占用的大小是 3.44 KB（0.81K+2.19K+0.19K+0.25K）</strong>。<br><img src="image-4.png" alt="TCP对象内存开销总结"></p><p>也就是，每一条静止状态的TCP连接大约需要吃 3.44K 的内存。</p><p>那么 <strong>8 GB 物理内存的服务器，最大能支持的 TCP 连接数&#x3D;8GB&#x2F;3.44KB&#x3D;2,438,956（约240万）</strong>！</p><p>当然， 实际过程中的 TCP 连接，肯定不是静止状态的，还会进行发送数据和接收数据了，那么这些过程还是会额外消耗更多的内存资源的，并发很难达到百万级别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>一个服务端进程最多能支持多少条 TCP 连接？</code></pre><p>如果在不考虑服务器的内存和文件句柄资源的情况下，理论上一个服务端进程最多能支持约为 2 的 48 次方（2^32 (ip数) * 2^16 (端口数），约等于两百多万亿！</p><p>但是在实际中是支持不了这个数值的，每个 TCP 连接都是一个文件，会占用文件句柄资源，也会占用一定的内存空间。</p><pre><code>一台服务器最大最多能支持多少条 TCP 连接？</code></pre><p>一台服务器是可以有多个服务端进程的，每个服务端进程监听不同的端口，当然所有65535个端口你都可以用来监听一遍。</p><p>当然所有65535个端口你都可以用来监听一遍，这样理论上线就到了2的32次方（ip数）×2的16次方（port数）×2的16次方（服务器port数）个，这个基本相当于无穷个了。</p><p>但是 Linux每维护一条TCP连接都要花费内存资源的，每一条静止状态（不发送数据和不接收数据）的 TCP 连接大约需要吃 3.44K 的内存，那么 8 GB 物理内存的服务器，最大能支持的 TCP 连接数&#x3D;8GB&#x2F;3.44KB&#x3D;2,438,956（约240万）。</p><p>实际过程中的 TCP 连接，还会进行发送数据和接收数据了，那么这些过程还是会额外消耗更多的内存资源的，并发很难达到百万级别。</p><hr><p>#文章来源</p><p><a href="https://mp.weixin.qq.com/s/l9ggXLAEHp4LTjd2Qsyqtg">腾讯三面：一台服务器，最大支持的TCP连接数是多少？</a></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/TCP%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5-%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%A7TCP%E8%BF%9E%E6%8E%A5/">TCP最大连接 进程最大TCP连接</category>
      
      
      <comments>http://example.com/2024/02/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%80%E5%A4%A7%E6%94%AF%E6%8C%81%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%E6%95%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Go教程</title>
      <link>http://example.com/2024/01/25/Go%E6%95%99%E7%A8%8B/</link>
      <guid>http://example.com/2024/01/25/Go%E6%95%99%E7%A8%8B/</guid>
      <pubDate>Thu, 25 Jan 2024 06:33:43 GMT</pubDate>
      
      
      
      
      
      
      <comments>http://example.com/2024/01/25/Go%E6%95%99%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Ubuntu杂记</title>
      <link>http://example.com/2024/01/15/Ubuntu%E6%9D%82%E8%AE%B0/Ubuntu%E6%9D%82%E8%AE%B0/</link>
      <guid>http://example.com/2024/01/15/Ubuntu%E6%9D%82%E8%AE%B0/Ubuntu%E6%9D%82%E8%AE%B0/</guid>
      <pubDate>Mon, 15 Jan 2024 05:31:46 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Remmina安装&quot;&gt;&lt;a href=&quot;#Remmina安装&quot; class=&quot;headerlink&quot; title=&quot;Remmina安装&quot;&gt;&lt;/a&gt;Remmina安装&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Remmina安装"><a href="#Remmina安装" class="headerlink" title="Remmina安装"></a>Remmina安装</h1><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">------------ 在 Debian/Ubuntu 中 ------------ </span><br><span class="line">$ sudo apt-get install remmina remmina-plugin-*</span><br><span class="line">------------ 在 CentOS/RHEL 中 ------------ </span><br><span class="line"><span class="comment"># yum install remmina remmina-plugin-*</span></span><br><span class="line">------------ 在 Fedora 22+ 中 ------------ </span><br><span class="line">$ sudo dnf copr <span class="built_in">enable</span> hubbitus/remmina-next</span><br><span class="line">$ sudo dnf upgrade --refresh <span class="string">&#x27;remmina*&#x27;</span> <span class="string">&#x27;freerdp*&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="命令行模式下进行Wi-Fi连接"><a href="#命令行模式下进行Wi-Fi连接" class="headerlink" title="命令行模式下进行Wi-Fi连接"></a>命令行模式下进行Wi-Fi连接</h1><h2 id="确认无线网卡的名字"><a href="#确认无线网卡的名字" class="headerlink" title="确认无线网卡的名字"></a>确认无线网卡的名字</h2><p>使用命令行 <code>iwconfig</code> 来确认无线网卡的名字，例如我的无线网卡为：wlp2s0</p><h2 id="扫描当前可用Wi-Fi"><a href="#扫描当前可用Wi-Fi" class="headerlink" title="扫描当前可用Wi-Fi"></a>扫描当前可用Wi-Fi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iw dev wlp2s0 scan | less  <span class="comment">#其中wlp2s0是刚才的无线网卡的名字</span></span><br></pre></td></tr></table></figure><p>如果报错iw找不到该命令时，可以使用下面命令安装iw</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install iw -y</span><br></pre></td></tr></table></figure><h2 id="设置登录-WIFI-和密码"><a href="#设置登录-WIFI-和密码" class="headerlink" title="设置登录 WIFI 和密码"></a>设置登录 WIFI 和密码</h2><p>通过如下命令行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> -i</span><br><span class="line"><span class="comment"># wpa_passphrase mywireless secretpassphrase &gt; /etc/wpa_supplicant/wpa_supplicant.conf</span></span><br><span class="line">特殊说明：</span><br><span class="line">1、mywireless 表示你要登录的 wifi 名字</span><br><span class="line">2、secretpassphrase 表示 wifi 登录的密码</span><br></pre></td></tr></table></figure><p>上述命令创建了一个conf文件，可以使用cat查看；</p><h2 id="加载配置文件，连接对应Wi-Fi"><a href="#加载配置文件，连接对应Wi-Fi" class="headerlink" title="加载配置文件，连接对应Wi-Fi"></a>加载配置文件，连接对应Wi-Fi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_supplicant -i wlp2s0 -c /etc/wpa_supplicant/wpa_supplicant.conf -B</span><br></pre></td></tr></table></figure><p>如果命令行返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Successfully initialized wpa_supplicant 则成功连接对应Wi-Fi。</span><br></pre></td></tr></table></figure><p>如果命令行返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl80211: kernel reports: Match already configured</span><br></pre></td></tr></table></figure><p>执行下述命令杀进程，再连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo killall wpa_supplicant</span><br><span class="line">sudo wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>大功告成。</p><h1 id="在Ubuntu-Linux上安装Chrome浏览器的最佳方法"><a href="#在Ubuntu-Linux上安装Chrome浏览器的最佳方法" class="headerlink" title="在Ubuntu Linux上安装Chrome浏览器的最佳方法"></a>在Ubuntu Linux上安装Chrome浏览器的最佳方法</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="string">&quot;https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb&quot;</span> -O google.deb</span><br><span class="line"></span><br><span class="line">sudo dpkg -i google.deb</span><br></pre></td></tr></table></figure><h1 id="Linux入门之安装ubuntu的两种选择（双系统篇）"><a href="#Linux入门之安装ubuntu的两种选择（双系统篇）" class="headerlink" title="Linux入门之安装ubuntu的两种选择（双系统篇）"></a>Linux入门之安装ubuntu的两种选择（双系统篇）</h1><p>安装双系统后使用grub引导，默认启动项为ubuntu，且选择启动项界面等待时间长达10秒，虽然安装了双系统，但是常用的毕竟还是windows，这里提供一种将默认启动项改为windows并缩短等待时间的方法。在终端输入如下命令对grub进行编辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>找到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DEFAULT=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GRUB_HIDDEN_TIMEOUT=0</span></span><br><span class="line"></span><br><span class="line">GRUB_HIDDEN_TIMEOUT_QUIET=true</span><br><span class="line"></span><br><span class="line">GRUB_TIMEOUT=10</span><br></pre></td></tr></table></figure><ul><li>GRUB_DEFAULT的值就是默认启动项的位置值，以前面介绍的方式安装双系统后，windows一般是第五个启动项，所以我们把这里改为4（程序员的习惯）;</li><li>GRUB_TIMEOUT就是选择启动项界面的等待时间，默认为10秒，根据喜好改成相应的秒数，更改完成后保存退出;<br>在终端输入<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>使更改生效，下次启动就默认为windows了。</li></ul><hr><p><a href="https://blog.csdn.net/seveneagleline/article/details/120952404">树莓派 wifi命令行连接没有报错但连接不上的问题</a></p><p><a href="https://blog.csdn.net/justidle/article/details/106585520">Ubuntu使用命令行配置WIFI</a></p><p><a href="https://zhuanlan.zhihu.com/p/25433899#:~:text=1%20%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%90%8E%E4%BD%BF%E7%94%A8grub%E5%BC%95%E5%AF%BC%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E9%A1%B9%E4%B8%BAubuntu%EF%BC%8C%E4%B8%94%E9%80%89%E6%8B%A9%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%95%8C%E9%9D%A2%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF%E8%BE%BE10%E7%A7%92%EF%BC%8C%E8%99%BD%E7%84%B6%E5%AE%89%E8%A3%85%E4%BA%86%E5%8F%8C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BD%86%E6%98%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AF%95%E7%AB%9F%E8%BF%98%E6%98%AFwindows%EF%BC%8C%E8%BF%99%E9%87%8C%E6%8F%90%E4%BE%9B%E4%B8%80%E7%A7%8D%E5%B0%86%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E9%A1%B9%E6%94%B9%E4%B8%BAwindows%E5%B9%B6%E7%BC%A9%E7%9F%AD%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%20%E5%9C%A8%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5%E5%A6%82%E4%B8%8B%E5%91%BD%E4%BB%A4%E5%AF%B9grub%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%BE%91%EF%BC%9A%202%20sudo%20vim%20%2Fetc%2Fdefault%2Fgrub%20%E6%89%BE%E5%88%B0%EF%BC%9A,GRUB_DEFAULT%3D0%20%20%23GRUB_HIDDEN_TIMEOUT%3D0%20%20GRUB_HIDDEN_TIMEOUT_QUIET%3Dtrue%20%20GRUB_TIMEOUT%3D10%20">Linux入门之安装ubuntu的两种选择（双系统篇）</a></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/Ubuntu-Remmina-%E5%91%BD%E4%BB%A4%E8%A1%8CWi-Fi%E8%BF%9E%E6%8E%A5-Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%90%AF%E5%8A%A8%E9%A1%B9/">Ubuntu Remmina 命令行Wi-Fi连接 Linux环境下更换启动项</category>
      
      
      <comments>http://example.com/2024/01/15/Ubuntu%E6%9D%82%E8%AE%B0/Ubuntu%E6%9D%82%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>python教程</title>
      <link>http://example.com/2023/12/06/python%E6%95%99%E7%A8%8B/</link>
      <guid>http://example.com/2023/12/06/python%E6%95%99%E7%A8%8B/</guid>
      <pubDate>Wed, 06 Dec 2023 06:26:46 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h1&gt;&lt;p&gt;适用于网站编程，脚本编程，科学计算和最近非常热门的AI。&lt;br&gt;Python是解释型语言，程序不需要编译，程序在运行时才翻译成机器语言并执行。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>适用于网站编程，脚本编程，科学计算和最近非常热门的AI。<br>Python是解释型语言，程序不需要编译，程序在运行时才翻译成机器语言并执行。</p><span id="more"></span><h2 id="第一个程序："><a href="#第一个程序：" class="headerlink" title="第一个程序："></a>第一个程序：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print（“Hello world！”）</span><br></pre></td></tr></table></figure><p>和C语言的printf不一样！！！</p><h2 id="简单运算符"><a href="#简单运算符" class="headerlink" title="简单运算符"></a>简单运算符</h2><p>Python有加（+）减（-）运算符，乘法（*）和除法（&#x2F;）运算符。</p><ul><li>注意：使用除法在Python中会产生一个十进制浮点数。</li><li>Python同样可以进行负数运算。在数字前面加一个减号即可。</li><li>和数学一样，除数不能为0.</li></ul><h2 id="浮点"><a href="#浮点" class="headerlink" title="浮点"></a>浮点</h2><p>在Python中浮点表示非整数，例如：3.14和-1.23432432</p><ul><li>浮点数可以用除法和小数来创建。</li><li>小数点后第二位开始的最右边0将被忽略，例如：0.500000会显示0.5，但15.0还是会显示15.0 。</li><li>Python最多能表示小数位后16位，大于16位的数将被忽略。</li><li>两整数相除为浮点数；两个浮点数运算或整数和浮点数运算都被处理成浮点。</li><li>浮点数和整数运算中，Python自动把整数转换成浮点，这是Python规则的一部分。</li></ul><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><h3 id="幂乘"><a href="#幂乘" class="headerlink" title="幂乘"></a>幂乘</h3><p>幂乘也叫乘法。即n个相同乘数的乘积运算。      </p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">5</span>   </span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">32</span>    （即<span class="number">2</span>的<span class="number">5</span>次方为<span class="number">32</span>）     </span><br></pre></td></tr></table></figure><p>幂乘运算符用 ** 表示。      </p><h3 id="商和余数"><a href="#商和余数" class="headerlink" title="商和余数"></a>商和余数</h3><p>在Python中使用除后取整运算符和取余运算符来做商和余数的运算。    </p><ul><li>除后取整运算符用&#x2F;&#x2F; 来表示，取余运算符用% 来表示。</li></ul><p>实例： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> // <span class="number">6</span>   </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>    </span><br></pre></td></tr></table></figure><p>实例2：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.25</span>%<span class="number">0.5</span>  </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.25</span>     </span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><p>类似于C 语言中的string，Python中字符串就是一串字符。</p><ul><li>字符串是以单引号 ‘’  或双引号 “” 括起来的任意文本，所有引号内的空间，如空格与制表符，都将按照原样保留。</li><li>字符串是不可变的。</li></ul><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>有些字符不能直接包含在字符串中，如单引号不能直接放置在用单引号表示的string对象里。会使Python无法识别哪儿是字符串的开始，哪儿是结束。</p><ul><li>通过转义字符反斜杠 \ 可以处理这种问题，</li><li>其他必须转义的常见的字符串有：换行符、制表符、反斜杠。</li></ul><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‘I\’m a boy !’      </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I‘m a boy !</span><br></pre></td></tr></table></figure><ul><li>反斜杠也可用于转义制表符，任意Unicode字符以及其他无法可靠打印的内容，这些字符称为转义字符。</li></ul><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>和C语言一样，换行符为“\n”.</p><ul><li><p>使用三个双引号或单引号创建的字符串保留原始的输入状态，在其里面的回车被自动转义为 \n 。</p></li><li><p>在三个引号表示的字符串中不需要转义字符，可以在字符串里自由的使用单引号与双引号，就像正常的输入一样，回车键在输出力也被 \n 转义符自动转义。<br><img src="python1.jpg"></p></li></ul><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>使用print 函数来生成输出，将在屏幕上显示其文本表现形式。     </p><ul><li>当输出字符串对象时，生成字符串对象的引号不会被显示。</li></ul><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>要从Python 用户获得输入，可以使用input函数，</p><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter something please:&quot;</span>))</span><br></pre></td></tr></table></figure><p>运行结果：<br>输出所输入的值。</p><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><ul><li>使用加号 + 将两个字符串连接在一起。</li><li>即使字符串包含数字，他们仍然是以字符串形式连接在一起。</li><li>字符串和数字相加会产生错误，他们是两个不同的对象。</li></ul><p>实例： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">2</span>”  +  “<span class="number">2</span>”  </span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">’<span class="number">22</span>’</span><br></pre></td></tr></table></figure><h3 id="字符串运算符-1"><a href="#字符串运算符-1" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><ul><li>字符串可以乘以整数，将产生新的字符串，结果是原始字符串的重复倍数，字符串和整数的顺序不重要。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;spam&quot;</span> * <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spamspamspam</span><br></pre></td></tr></table></figure><ul><li>除了乘以整数外，字符串不能与其他字符串相乘，字符串也不能乘以浮点数。</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><p>和C语言类似，可以使用类型转换来强制转换，eg使用 int 函数来转换字符串到整数。</p><ul><li><p>在Python中，目前学过的基本类型整数、浮点数、字符串，用于转换为这些函数分别为： int、float、str。</p></li><li><p>类型转换的另一个例子是将用户输入（即字符串）转换为数字（整数或浮点数）。</p></li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a number:&quot;</span>)) + <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter another number:&quot;</span>)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><figcaption><span>a number:13</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter another number:23</span><br><span class="line">36.0</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><p>变量在Python中是非常重要的概念。变量就是一个有值的代号，变量允许通过将值赋值给名称，该名称可用于引用后面定义的值。</p><p>赋值语句的作用就是创建一个新的变量，并且赋值给这个变量。赋值语句用等号 &#x3D; 分割，左边是变量，右边是该变量的值。</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x =  <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x +<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运算结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">10</span><br><span class="line">7</span><br></pre></td></tr></table></figure><ul><li><p>可以使用变量来执行相应的操作，就像对数字和字符串所做的那样。</p></li><li><p>在python 中变量只是一个指向，可以多次重新更改它们的值。这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。</p></li><li><p>变量没有特定的类型，可以将字符串分配给变量，然后再讲整数赋值给同一个变量。</p></li><li><p>Python是弱类型语言，变量没有特定的类型，其它强类型语言的变量是不能从一个类型的赋值转到给另一个类型赋值。</p></li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x =  <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;this is a string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x +<span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">this is a string!</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>变量名必须为大小写英文、数字和_ 的组合，不能用数字开头。</p></li><li><p>变量不能是Python 里面的关键字</p></li><li><p>Python是一种区分大小写的编程语言。</p></li><li><p>任何试图引用未分配的变量都会导致错误。</p></li></ul><p>可以使用del 语句删除变量，这意味着名称和值的引用都被删除.</p><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="string">&quot;a string &quot;</span></span><br><span class="line"><span class="built_in">print</span>(foo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span>  foo</span><br><span class="line"><span class="built_in">print</span>(foo)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a string</span><br><span class="line"></span><br><span class="line">NameError: name <span class="string">&#x27;foo&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="built_in">input</span>(<span class="string">&quot;Enter a number: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: <span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="原地修改运算符"><a href="#原地修改运算符" class="headerlink" title="原地修改运算符"></a>原地修改运算符</h2><h3 id="原地修改运算符-1"><a href="#原地修改运算符-1" class="headerlink" title="原地修改运算符"></a>原地修改运算符</h3><ul><li><p>原地修改运算符就是用于修改自身的运算符。我们可以把 x &#x3D; x + 3 写成 x+&#x3D;3.</p></li><li><p>还包含    -&#x3D;     *&#x3D;      &#x2F;&#x3D;    %&#x3D;</p></li><li><p>原地修改运算符可以用来修改数字，也可用来修改字符串。</p></li><li><p>许多其他语言都有特殊的运算符，例如 “++x” 作为 “x +&#x3D;1” 的快捷方式，但是Python没有这些运算符</p></li><li><p>Python中整数是一种不可变类型，因此，无法实现自增和自减操作。</p></li></ul><h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><h2 id="布尔比较"><a href="#布尔比较" class="headerlink" title="布尔比较"></a>布尔比较</h2><p>Python中布尔类型（Boolean）包含两个值：True 和False。</p><ul><li>两种方式可以声明数据类型是布尔型。一种直接声明，另一种通过值比较产生。</li><li>注意赋值运算符  &#x3D;  和等于比较运算符&#x3D;&#x3D; 是不同的。</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li><p>不等于运算符为   ！&#x3D;<br>大于  &gt;        小于 &lt;<br>大于或等于  &gt;&#x3D;    小于或等于 &lt;&#x3D; </p></li><li><p>大于或小于运算符也可以用于按字母顺序比较字符串（单词的字母顺序是基于其组成的字母顺序）</p></li></ul><h2 id="If语句"><a href="#If语句" class="headerlink" title="If语句"></a>If语句</h2><h3 id="If条件判断"><a href="#If条件判断" class="headerlink" title="If条件判断"></a>If条件判断</h3><p>空白区在Python中十分重要。被称为缩进（indentation）。在逻辑行的开头留下空白区（使用空格或制表符）用以确定各逻辑行的缩进级别，而后者又可用于确定语句的分组。</p><ul><li>放置在一起的语句必须拥有相同的缩进。每一组这样的语句被称为块（block）。</li><li><strong>If格式在写程序时注意不要忘记冒号 ：</strong></li></ul><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">10</span> &gt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;10 greater than 5&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Program ended&quot;</span>)</span><br></pre></td></tr></table></figure><p>运算结果;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> greater than <span class="number">5</span></span><br><span class="line">Program ended</span><br></pre></td></tr></table></figure><ul><li>注意if 声明中的比较运算表达式要用冒号来结束。</li><li>如果程序包含多行代码，应该将其创建一个文件并保存代码。在命令行下使用Python on filename来运行它。</li><li>If语句里面可以嵌套更多的if 语句。</li></ul><h2 id="else-语句"><a href="#else-语句" class="headerlink" title="else 语句"></a>else 语句</h2><ul><li>如果一个包含else 语句的 if条件判断，当if 条件的判断值为 false 时，运行 else里的语句。</li><li>像if 语句一样， else语句的代码也必须缩进。</li><li>Else 语句也必须像if 语句一样后面跟着冒号：  。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">4</span></span><br><span class="line"><span class="keyword">if</span> x==<span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure><p>运算结果;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="elif-语句"><a href="#elif-语句" class="headerlink" title="elif 语句"></a>elif 语句</h3><p>elif 语句是 else if 的缩写，主要用于多重判断的语句。</p><ul><li>If elif 多重判断语句最后可以放置 else 语句，当前面 if elif 多重判断语句最终无法在所有的分支上得出结果为True情况下，程序运行 else 语句。</li><li>If 语句执行有个特点，是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略剩下的elif和else 语句。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num  = <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number is 5&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">11</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number is 11&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">7</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number is 7&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number is not 5, 11 or 7&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number <span class="keyword">is</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="布尔逻辑判断"><a href="#布尔逻辑判断" class="headerlink" title="布尔逻辑判断"></a>布尔逻辑判断</h2><p>布尔逻辑判断用于为依赖于多个条件的if 语句创造更复杂的条件。</p><ul><li>Python布尔逻辑运算符包含：and or 和not。</li><li>Python使用三个单词作为布尔逻辑运算符，其他语言使用&amp;&amp;    ||    和  ！</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span> == <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> ==<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> == <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> ==<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> != <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> ==<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="or运算符"><a href="#or运算符" class="headerlink" title="or运算符"></a>or运算符</h3><p>or运算符评估其运算符两边的结果，如果其中有一边运算的结果为TRUE则返回 True，如果两边的结果都为false，返回false。</p><h3 id="not运算符"><a href="#not运算符" class="headerlink" title="not运算符"></a>not运算符</h3><p>not 运算符值评估其右边的运算结果并返回相反的结果。not TRUE返回false，not false返回TRUE。</p><ul><li>可以在if 判断里使用多个布尔逻辑运算符来处理多个条件判断。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">1</span> &gt; <span class="number">7</span>)</span><br></pre></td></tr></table></figure>运算结果：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h2><ul><li>&#x3D;&#x3D; 运算符的优先级高于 or 运算符。</li><li>Python的运算顺序于普通数学的顺序相同：首先是括号，然后是指数，然后是乘除法，然后加减法。</li></ul><p>下面的表格表示Python里由高到低的运算优先级。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>指数（最高优先级）</td></tr><tr><td>～+-</td><td>按位反转，一元加号和减号（最后两个的方法名为+@和-@）</td></tr><tr><td>*&#x2F;% &#x2F;&#x2F;</td><td>乘、除、取模和取整除</td></tr><tr><td>+-</td><td>加减法</td></tr><tr><td>&gt;&gt; &lt;&lt;</td><td>右移，左移运算符</td></tr><tr><td>&amp;</td><td>位 ‘AND’</td></tr><tr><td>^|</td><td>位运算符</td></tr><tr><td>&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td>比较运算符</td></tr><tr><td>&lt;&gt;&#x3D;&#x3D; !&#x3D;</td><td>等于运算符</td></tr><tr><td>&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td>赋值运算符</td></tr><tr><td>is is not</td><td>身份运算符</td></tr><tr><td>in not in</td><td>成员运算符</td></tr><tr><td>not or and</td><td>逻辑运算符</td></tr></tbody></table><h2 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h2><p>和C语言的while功能一样，使用格式见下面的程序例子：</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span> :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finished&quot;</span>)</span><br></pre></td></tr></table></figure><p>运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">Finished</span><br></pre></td></tr></table></figure><ul><li>While 如果条件判断一直未TRUE，可以是死循环。</li><li>如果需要在代码中跳出while循环，可以使用break语句。当在循环中遇到break语句，循环立即跳出while循环语句。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Breaking&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finished&quot;</span>)</span><br></pre></td></tr></table></figure><p>运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">Breaking</span><br><span class="line">Finished</span><br></pre></td></tr></table></figure><ul><li>在循环外面使用break 语句将会导致错误发生。</li></ul><h3 id="Continue语句"><a href="#Continue语句" class="headerlink" title="Continue语句"></a>Continue语句</h3><p>循环里面我们还可以使用continue语句。</p><ul><li>不像break跳出整个循环并停止执行循环代码块，continue语句停止执行循环代码块下面的部分并重新开始执行循环代码块。</li><li>Continue语句的作用是停止当前的循环并执行下一个循环。</li><li>在循环外面使用continue语句将会导致错误发生。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Skipping 2&quot;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Breaking&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finished&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">Skipping <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">Breaking</span><br><span class="line">Finished</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是一种保存一系列有序的集合，类似于C 语言的数组。</p><ul><li>需要把数据放在方括号里并让每一项都用逗号隔开，使用列表中的索引来访问列表中的特定项。</li><li>索引的第一项为0 不是 1，这和我们生活中实际情况有点不一样。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">words =  [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(words[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(words[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(words[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">world</span><br><span class="line">!</span><br></pre></td></tr></table></figure><ul><li>一个空列表是用一个空的方括号创建的。</li><li>大多数情况下，逗号不会出现在列表中的最后一项的后面，当然在那里放置一个逗号也是完全有效的语法。</li><li>通常列表包含单重类型，但也可以包含几种不同的类型。同时，列表里也能嵌套列表。</li><li>内嵌列表通常用于表示一个二维数组，因为Python缺少在其他语言中用于这种作用的多维数组。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">3</span></span><br><span class="line">things = [<span class="string">&quot;string&quot;</span>, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, number], <span class="number">4.56</span>]</span><br><span class="line"><span class="built_in">print</span>(things[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(things[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(things[<span class="number">2</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="列表运算符"><a href="#列表运算符" class="headerlink" title="列表运算符"></a>列表运算符</h2><p>列表里的列表元素可修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><p>运算结果;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><ul><li><p>加号 + 运算符可以吧列表拼接在一起，星号 * 运算符可以将列表重复指定的次数。</p></li><li><p>列表和字符串在很多方面的行为都是相似的，字符串可以看作是不能更改的字符列表。</p></li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(nums + [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(nums * <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>运算结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><ul><li>要检查一个元素是不是在列表里，可以使用in 运算符。返回 True 表示该元素存在，否则返回 false。</li><li>In 运算符还可以用于确定字符串是否是另一个字符串的子字符串。</li></ul><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&quot;spam&quot;</span>, <span class="string">&quot;egg&quot;</span>, <span class="string">&quot;spam&quot;</span>, <span class="string">&quot;sausage&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;spam&quot;</span> <span class="keyword">in</span> words)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;egg&quot;</span> <span class="keyword">in</span> words)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tomato&quot;</span> <span class="keyword">in</span> words)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>要检查一个元素不在列表里使用 not 运算符。</li></ul><h2 id="列表方法"><a href="#列表方法" class="headerlink" title="列表方法"></a>列表方法</h2><ul><li>要在列表尾部添加一个元素可以使用列表的append方法。</li><li>列表后面加点是因为它是列表类的一种方法，类方法将在后面的课上解释。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums =[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">nums.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><p>运算结果;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><ul><li>取得列表的长度，使用len函数。</li><li>与append不同，len是一个正常函数，而不是列表类的一个方法。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(nums))</span><br></pre></td></tr></table></figure>运行结果：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li><li>想将对象插入列表还可以使用insert 方法，不像append方法，它可以分配这个对象插入到哪个索引。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;fun&quot;</span>]</span><br><span class="line">index = <span class="number">1</span></span><br><span class="line">words.insert(index, <span class="string">&quot;is&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(words)</span><br></pre></td></tr></table></figure><p>运行结果;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>Index 方法被用于在发现对象在哪个索引编号，返回首次发现的索引编号，如果列表里没有对象跑出 ValueError错误。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(letters.index(<span class="string">&#x27;r&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(letters.index(<span class="string">&#x27;p&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(letters.index(<span class="string">&#x27;z&#x27;</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">ValueError: <span class="string">&#x27;z&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure><h2 id="range-函数"><a href="#range-函数" class="headerlink" title="range 函数"></a>range 函数</h2><ul><li>Range 函数创建一个包含顺序数字的对象，下面的代码创建一个从0 到小于10 的列表。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><ul><li>上面的代码调用了list方法强制类型转换。因为range函数本身会创建range对象，如果要将其作为一个列表使用，则必须将其转换为列表。</li><li>Range函数接受一个参数是 ，它创建一个从0 到小于参数的一个有序序列。</li><li>如果接受两个参数，它创建一个从第一个参数开始到小于第二个参数的一个序列。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">range</span>(<span class="number">20</span>) == <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>range 函数默认每次产生有序序列式迭是对序列尾数加 1 操作，但是如果其有第三个参数，那么产生数字序列相加的数就以第三个数为准。即第三个是步长。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>遍历一个列表中所有元素可以通过一个while循环和一个计数器变量来完成。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;spam&quot;</span>, <span class="string">&quot;eggs&quot;</span>]</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line">max_index = <span class="built_in">len</span>(words) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> counter &lt;= max_index:</span><br><span class="line">    word = words[counter]</span><br><span class="line">    <span class="built_in">print</span>(word + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">    counter =counter + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello!</span><br><span class="line">world!</span><br><span class="line">spam!</span><br><span class="line">eggs!</span><br></pre></td></tr></table></figure><ul><li>上面示例遍历列表中所有项，使用索引编号访问它们，并添加感叹号来打印它们。</li><li>上面的用while的循环来遍历列表有点太麻烦，Python提供了一个更简便的方法，也是最常用的方法就是for循环。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;spam&quot;</span>, <span class="string">&quot;eggs&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">     <span class="built_in">print</span>(word + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello!</span><br><span class="line">world!</span><br><span class="line">spam!</span><br><span class="line">eggs!</span><br></pre></td></tr></table></figure><ul><li>Python里的for 循环像其它语言中的foreach 循环。</li><li>For循环用于重复某些代码一定次数，通过将 for 循环与 range 对象结合起来用。</li><li>在for循环中使用range对象时，不需要调用list函数。因为不需要被索引，所以不需要将它转换成列表。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello!</span><br><span class="line">hello!</span><br><span class="line">hello!</span><br><span class="line">hello!</span><br><span class="line">hello!</span><br></pre></td></tr></table></figure><h1 id="函数和模块"><a href="#函数和模块" class="headerlink" title="函数和模块"></a>函数和模块</h1><h2 id="代码重用"><a href="#代码重用" class="headerlink" title="代码重用"></a>代码重用</h2><ul><li>在软件工程里，必须遵守不要编写同一代码的原则。英文 Don’t Repeat Yourself，简称：DRY原则。</li><li>重复的代码被认为是遵循WET原则，即表示英语Write Everything Twice 的简写，或者 We Enjoy Typing的简写。</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数调用就是左边是需要调用的函数的名称，后面跟着圆括号。</p><ul><li>括号前面的单词是函数名，括号内以逗号分隔的值是函数参数。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">str</span>(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h3><ul><li>函数可以通过关键字 def 来定义，关键字后跟着一个函数的标识符，接下来是一对圆括号，圆括号里可以包括一些变量的名称。再以冒号结尾结束这一行。后面缩进的语句块是函数的一部分</li><li>所有函数的代码块是通过缩进来定义的，函数命名后面要跟随冒号。</li></ul><p>实例1:<br>下面代码声明一个叫my_func的函数。当调用这个函数时打印spam三次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>() :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;spam&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;spam&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;spam&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_func()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spam</span><br><span class="line">spam</span><br><span class="line">spam</span><br></pre></td></tr></table></figure><ul><li>函数调用必须在函数声明之后。如果调用在声明前，程序发生异常。</li></ul><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>函数名后面的括号是空的，意思是这个函数不需要参数，实际上，大多数函数都是有参数的。</p><ul><li>参数定义在圆括号里面。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">word</span>) :</span><br><span class="line">    <span class="built_in">print</span>(word + <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_func(<span class="string">&quot;spam&quot;</span>)</span><br><span class="line">my_func(<span class="string">&quot;eggs&quot;</span>)</span><br><span class="line">my_func(<span class="string">&quot;python&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spam!</span><br><span class="line">eggs!</span><br><span class="line">python!</span><br></pre></td></tr></table></figure><ul><li>同样，可以定义一个包含多个参数的函数，参数用逗号分隔开。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">x, y</span>) :</span><br><span class="line">    <span class="built_in">print</span>(x + y)</span><br><span class="line">    <span class="built_in">print</span>(x + y)</span><br><span class="line">my_func(<span class="number">5</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><p>函数参数可以用作函数块定义中的变量，仅在函数体内部存在，不能在函数定义之外引用它们，同样这也适用于在函数中创建的其他变量。</p><ul><li>从技术上讲，参数是函数定义中的变量，参数的值在调用时被函数赋值了。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">variable</span>):</span><br><span class="line">    variable  +=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(variable)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(variable)</span><br></pre></td></tr></table></figure><p>运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">NameError: name <span class="string">&#x27;variable&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>我们见到一些内置函数比如float 都返回一个值。要返回一个值，在函数体内部可以用return 随时返回函数结果。</p><ul><li>Return语句不能在函数外面使用，函数执行完毕没有return语句时，函数自动产生return None。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt;=y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="number">4</span>,<span class="number">7</span>))</span><br><span class="line">z = <span class="built_in">max</span>(<span class="number">8</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><ul><li>当从函数返回一个值，程序立即停止执行并返回，return 下面的代码不会执行。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">x, y</span>):</span><br><span class="line">    total = x + y</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This won&#x27;t be printed&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(add_numbers(<span class="number">4</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="备注和文档解释"><a href="#备注和文档解释" class="headerlink" title="备注和文档解释"></a>备注和文档解释</h2><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>注释是代码的注解，用于使代码更容易理解，它们不影响代码的运行方式。<br>Python中，注释是通过插入哈希符号 # 来实现的，改行在 # 之后的所有文本都被程序忽略。</p><p>Python没有多行注释，其它编程语言有多行注释功能，使用 &#x2F;* *&#x2F;语法。</p><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>文档注释有点和注释相同，因为它们是用来解释代码的。<br>通过在函数或类的第一行下面放置一个包含多行字符串方式来创建的。</p><ul><li>文档注释是字符串的另一种表现，运行时会被保留在程序或类里并能被用 _doc_变量读到。</li><li>文档注释一般给类和函数做注释，而单行注释一般用来说明某一行的功能。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shout</span>(<span class="params">word</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  print a word with an exclamation mark following it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(word + <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line">shout(<span class="string">&quot;spam&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam!</span><br></pre></td></tr></table></figure><h2 id="函数即对象"><a href="#函数即对象" class="headerlink" title="函数即对象"></a>函数即对象</h2><h3 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h3><p>虽然他们的创建和普通变量不同，但函数就像任何其他类型的值一样，可以将他们重新分配给变量，然后对引用调用。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span> (x, y):</span><br><span class="line">    <span class="keyword">return</span>  x * y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">7</span></span><br><span class="line">operation = multiply</span><br><span class="line"><span class="built_in">print</span>(operation(a, b))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><p>上面的例子将乘法函数重新指派了一个变量名，现在我们可以用变量名来调用函数。</p><ul><li>函数还可以被当做参数来调用。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y </span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_twice</span>(<span class="params">func,x,y</span>):</span><br><span class="line">    <span class="keyword">return</span>  func(func(x,y), func(x,y))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(do_twice(add, a , b))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p>上面的例子函数add被函数 do_twice 当成参数并在函数体里面调用。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块（modules）是为完成常见任务而编写的代码，例如生成随机数，执行数学操作等。</p><ul><li>模块的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。使用模块还可以避免函数名和变量名冲突。</li><li>使用模块的基本方法是在代码的顶部添加import module_name 代码，然后使用模块module_name .var 访问模块中的变量名称的函数和值。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    value = random.randint(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>上面diamante使用random 模块中定义的randint 函数在1 到 6 的范围内打印5 个随机数。</p><ul><li><p>如果仅需要模块中的某些函数，可以使用另一种导入模块的方法。</p></li><li><p>采用 from module_name import var 的方式导入函数var后就可以使用var，就好像它是在代码中定义的一样。</p></li><li><p>使用逗号分隔列表可以导入多个函数。</p></li><li><ul><li>表示从模块中导入所有的函数，比如： from math import *</li></ul></li><li><p>通常不鼓励这么做，因为它混淆了代码中的变量和外部模块中的变量。</p></li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span>  pi</span><br><span class="line"><span class="built_in">print</span>(pi)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span>  pi,sqrt</span><br></pre></td></tr></table></figure><ul><li>可以使用as 关键字以不同的命名来导入模块或对象，这可以用在模块或对象有一个长的或令人困惑的名称时。</li></ul><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt <span class="keyword">as</span> square_root</span><br><span class="line"><span class="built_in">print</span>(square_root(<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.0</span></span><br></pre></td></tr></table></figure><h2 id="标准库和pip（不熟悉）"><a href="#标准库和pip（不熟悉）" class="headerlink" title="标准库和pip（不熟悉）"></a>标准库和pip（不熟悉）</h2><ul><li>Python中有三种主要类型的模块：<br>自己编写的模块、从外部源安装的模块以及与Python一起预装的模块。</li><li>预装的模块叫做标准库，包含一些常用的模块，标准库里包含的模块包括：</li><li>String ,  re,  datetime , math  ,random,  os ,  multiprocessing,  subprocess,<br>Socket,    email    json     doctest   unittest    pdb    argparse   sys 等。</li></ul><p>标准库可以完成的任务包括字符串解析、数据序列化、测试、调试和操作日期、电子邮件、命令行参数等。</p><ul><li>Python的标准库拥有大量模块，这是他作为一种语言的主要优势之一。</li></ul><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>完整的标准库文档可以访问<a href="http://www.python.org/">www.python.org</a> 上面有英语、法语和日语版本。</p><h3 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h3><p>在Python中安装第三方模块是通过pip这个工具完成的，此工具随着Python安装程序安装到机器中，要安装的一个库，转到命令行（对于Windows，它将是命令提示符）。输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install library_name</span><br></pre></td></tr></table></figure><p>。安装完成后就可以导入library_name这个模块并使用了。</p><p>使用pip这个工具是在大多数操作系统上安装第三方库的标准方法，有些库已经为Windows预先构建了二进制文件，这些是普通的可以执行文件，也可以是使用GUI安装库，就像安装其他程序一样。</p><h1 id="例外和文件"><a href="#例外和文件" class="headerlink" title="例外和文件"></a>例外和文件</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常也叫例外。当程序出现意外情况时就会发生异常并终止运行。</p><ul><li>除数为0 产生   ZeroDivisionError   异常；</li><li>ImportError :  引入模块错误，通常是模块不存在。</li><li>IndexError：读取列表超出索引范围。</li><li>NameError：使用未声明的变量。</li><li>SyntaxError：代码语法错误。</li><li>TypeError：当操作或函数处理不合适类型。</li><li>ValueError：内建操作或函数，接收到类型正确，但值不正确。</li></ul><p>Python 还有其他几个内置的异常，比如ZeroDivisionError 和OSError。第三方库也经常定义自己的例外。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>我们使用 try &#x2F; except 语句捕捉程序运行产生的例外。<br>用 try 块用来包含可能产生异常的代码块。如果产生异常 try 块停止运行， except块里的代码开始运行，如果程序运行正常，则不会运行except 块里的代码。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num1 = <span class="number">7</span></span><br><span class="line">    num2 = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(num1 / num2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Done calculation&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;An error occurred&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;due to zero division&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">An error occurred</span><br><span class="line">due to zero division</span><br></pre></td></tr></table></figure><ul><li>Try 语句可以拥有多个except定义语句来处理异常，多个异常也可以使用一个except块来捕捉。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   variable =  <span class="number">10</span></span><br><span class="line">   <span class="built_in">print</span>(variable + <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">   <span class="built_in">print</span>(variable / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Divided by zero&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> (ValueError, TypeError):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error occurred&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error occurred</span><br></pre></td></tr></table></figure><ul><li>Except 语句如果没有申明要捕捉的例外，将捕获所有的例外。应该谨慎地使用这种异常处理方式，它可以捕获意外错误但却隐藏了编程错误。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   word = <span class="string">&quot;spam&quot;</span></span><br><span class="line">   <span class="built_in">print</span>(word / <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;An error occured&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An error occurred</span><br></pre></td></tr></table></figure><p>这种异常处理方式通常用在处理用户输入。</p><h2 id="finally语句"><a href="#finally语句" class="headerlink" title="finally语句"></a>finally语句</h2><ul><li>假设正在读取一份文件，应该如何确保文件对象被正确关闭，无论是否会有异常发生。</li><li>为了确保代码最终能够运行一些代码不论是否有例外发生，我们可以使用finally语句。</li><li>finally语句放在  try &#x2F;except 语句的后面</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">1</span> / <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Divided by zero&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This code will run no matter what&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">Divided by zero</span><br><span class="line">This code will run no matter what</span><br></pre></td></tr></table></figure><ul><li>finally语句最终会被运行不管前面的例外有没有捕捉到，或者在except语句里产生了例外。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">10</span> / <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(unknown_var)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is executed last&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">This <span class="keyword">is</span> executed last</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line">NameError: name <span class="string">&#x27;unknown_var&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><h3 id="抛出异常-1"><a href="#抛出异常-1" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>使用raise语句抛出一个异常。</p><ul><li>需要声明要抛出的例外名称。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">raise</span> ValueError</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">ValueError</span><br></pre></td></tr></table></figure><ul><li>抛出的异常可以用参数来指出这是什么错误。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">raise</span> NameError(<span class="string">&quot;Invaild name!&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NameError: Invaild name!</span><br></pre></td></tr></table></figure><ul><li>在except 块里，raise语句可以不用声明异常的名称重新抛出捕获到的异常。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = <span class="number">5</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;An error occurred&quot;</span>)</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">An error occurred</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><h3 id="断言-1"><a href="#断言-1" class="headerlink" title="断言"></a>断言</h3><ul><li>Python的断言就是检测一个条件。如果条件为真，他什么都不做。反之它触发一个错误信息。</li><li>断言可以打开或关闭。断言使用assert语句声明。</li><li>程序员通常在函数的开头放置断言以检查有效的输入，在函数调用之后放置断言以检查有效的输出。</li><li>断言可以在运行时通过添加 –O 或 –OO选项来关闭。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure><ul><li>断言的第二个参数可以用来给AssertionError做参数。</li><li>AssertionError异常可以像任何其他异常一样使用 try &#x2F;except 语句被捕获和处理，如果程序不处理，这种类型的异常将终止程序的运行。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp = -<span class="number">10</span></span><br><span class="line"><span class="keyword">assert</span> (temp &gt;= <span class="number">0</span>),   <span class="string">&quot;Colder than do solute zero!&quot;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssertionError: Colder than do solute zero!</span><br></pre></td></tr></table></figure><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><h3 id="打开文件-1"><a href="#打开文件-1" class="headerlink" title="打开文件"></a>打开文件</h3><p>读写文件是最常见的IO（输入输出）操作。Python内置了读写文件的函数，要读写文件需要打开一个文件对象，使用open函数。</p><ul><li>Open 函数打开的对象在Python中统称为file-like Object.。除了文件外，还可以是内存的字节流，网络流，自定义流等等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfile = <span class="built_in">open</span>(<span class="string">&quot;filename.text&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>Open函数的参数是文件的路径。如果文件与程序位于同一个目录中，则可以不用指定路径直接使用文件名。</li><li>可以使用open函数的第二个参数来指定打开文件的模式。</li><li>使用“W”模式时，如果文件已经存在，会把旧文件的内容全部都清除掉。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># write mode</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#read mode</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#binary write mode</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>)</span><br></pre></td></tr></table></figure><p>访问模式列表：</p><table><thead><tr><th>访问模式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件，文件的指针将会放在文件的开头，这是默认模式</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>a</td><td>打开一个文件用户追加。如果该文件已经存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有的内容之后，如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后，如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>r+</td><td>打开一个文件用于读写，文件指针将会放在文件的开头</td></tr><tr><td>w+</td><td>打开一个文件用于读写，如果该文件已存在则将其覆盖。如果该文件不存在，创建新的文件。</td></tr><tr><td>a+</td><td>打开一个文件用于读写，如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写，文件指针将会放在文件的开头。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写，如果该文件已存在则将其覆盖，如果该文件不存在，创建新文件。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加，如果该文件已存在，文件指针将会放在文件的结尾，如果该文件不存在，创建新文件用于读写。</td></tr><tr><td></td><td></td></tr></tbody></table><ul><li>文件打开后应该使用close 方法关闭文件。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do stuff to the file</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><ul><li>使用open方法打开的文件可以使用read方法来读取内容。</li><li>打印文件名为filename.txt的所有内容。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">cont = file.read()</span><br><span class="line"><span class="built_in">print</span>(cont)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><ul><li>若要读取一定数量的文件内容，可以使用一个数字作为参数来调用read函数，该数字确定要读取多少个字节的内容。</li><li>可以对同一个文件对象进行多次的read调用，逐字节读取文件内容。在没有参数的情况下，read函数返回文件的其余部分。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(file.read(<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(file.read(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(file.read(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(file.read())</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><ul><li><p>当所有的内容被读取后，再调用read函数返回空字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">file.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Re-reading&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(file.read())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finished&quot;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Re-reading</span><br><span class="line"></span><br><span class="line">Finished</span><br></pre></td></tr></table></figure></li><li><p>要一行一行地读取，我们可以使用readline 方法。也是用readlines 一次读取所有内容并返回一个列表。列表里的每项元素表示一行内容。</p></li><li><p>在输出中，返回的行包含换行符，打印print 函数在输出的末尾自动添加新行。</p></li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(file.readlines())</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure><ul><li>使用for语句遍历文件的每一行：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></li></ul><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><ul><li>使用write方法吧内容写到文件里。</li><li>如果文件不存在，“w”模式将会创建一个文件。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">file.write(<span class="string">&quot;This has been written to a file&quot;</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(file.read())</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This has been written to a file</span><br></pre></td></tr></table></figure><ul><li>写入模式下，如果文件存在将清除全部内容并往文件里写入新内容。</li><li>文件将被新内容重写。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Reading initial contents&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(file.read())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finished&quot;</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file= <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">file.write(<span class="string">&quot;Some new text&quot;</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Reading new contents&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(file.read())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finished&quot;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reading initial contents</span><br><span class="line"></span><br><span class="line">Finished</span><br><span class="line">Reading new contents</span><br><span class="line">Some new text</span><br><span class="line">Finished</span><br></pre></td></tr></table></figure><ul><li>如果write 写入成功，方法返回写入的字节数。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;newfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">amount_written = file.write(msg)</span><br><span class="line"><span class="built_in">print</span>(amount_written)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>运算结果;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><ul><li>确保文件在使用后始终关闭，避免浪费资源是良好的编程习惯。使用try &#x2F;finally 语句。</li><li>当例外发生时也能确保文件对象被正确关闭。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Some new text</span><br></pre></td></tr></table></figure><ul><li>每次都这样要关闭文件实在太繁琐。所以，Python引入了with语句来帮助我们自动调用close方法。</li><li>使用with 语句打开文件是个好习惯，就算有例外发生，with语句也会自动帮我们关闭文件句柄。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure><p>运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Some new text</span><br></pre></td></tr></table></figure><h1 id="数据类型（不熟练）"><a href="#数据类型（不熟练）" class="headerlink" title="数据类型（不熟练）"></a>数据类型（不熟练）</h1><h2 id="None类型"><a href="#None类型" class="headerlink" title="None类型"></a>None类型</h2><ul><li>None类型是Python的特殊类型，是None Type的对象类型，表示无值。该对象只有一个值None。其它语言使用null来表示这种对象。</li><li>它不支持任何运算也没有任何内建方法。作为一个对象其布尔值值为false。除了和自己比较，None和任何其他的数据类型比较永远返回False。</li><li>如果函数没有清楚地声明返回值，则返回None对象。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">some_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi!&quot;</span>)</span><br><span class="line"></span><br><span class="line">var = some_func()</span><br><span class="line"><span class="built_in">print</span>(var)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi!</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li><p>字典（Dictionaries）是Python中一个非常有用的内置数据类型。它不像列表一样通过数字索引来访问，字典当中的元素是通过键来存取。</p></li><li><p>字典是一种映射类型，在其他语言中被称为map。 字典用{ } 来标识，使用键：值（key:value）存储，具有极快的查找速度，使用 [ ]语法来访问。</p></li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ages = &#123;<span class="string">&quot;Dave&quot;</span>: <span class="number">24</span>, <span class="string">&quot;Mary&quot;</span>: <span class="number">42</span>, <span class="string">&quot;John&quot;</span>: <span class="number">58</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(ages[<span class="string">&quot;Dave&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(ages[<span class="string">&quot;Mary&quot;</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><ul><li><p>访问不存在词典里的键值会导致KeyError例外。</p></li><li><p>实际上字典能够存储任何类型的数据。</p></li><li><p>字典为空时的表现形式为 { }</p></li><li><p>只有不可变的对象可以用作字典的key，不可变的对象是指那些不能更改的对象。到目前为止，我们遇到的唯一可变对象就是列表和字典。可变对象做键值会触发TypeError例外。</p></li><li><p>正确使用字典非常重要，需要牢记的第一条就是字典的key必须是不可变对象。</p></li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bad_dict = &#123; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] : <span class="string">&quot;one two three&quot;</span>, &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h2><h3 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h3><ul><li>我们知道字典是可变对象，可以像列表一样，字典的键值存储的数据可以重新指派另外的值。</li><li>不同于列表的是，可以通过字典的键值存储数据，不管这个键存不存在字典里。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squares = &#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="string">&quot;error&quot;</span>, <span class="number">4</span>: <span class="number">16</span>,&#125;</span><br><span class="line">squares[<span class="number">8</span>] = <span class="number">64</span></span><br><span class="line">squares[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(squares)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">8</span>: <span class="number">64</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>要在字典里确定一个键是否存在字典里，你可以使用in 语法。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">&quot;one&quot;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&quot;two&quot;</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">&quot;three&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> nums)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;three&quot;</span> <span class="keyword">in</span> nums)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span> <span class="keyword">not</span>  <span class="keyword">in</span> nums)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>还可以通过get 的方法从字典里取得数据，就像前面课程里 ages[“Dave”]这样的方式读取数据。与这种方式不同的是，当字典里没有该键值时 get 方法取回的值是None，而不是引发 KeyError例外。</li><li>还可以指定get 方法第二个参数，当键值在字典里不存在时返回的默认值。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pairs = &#123; <span class="number">1</span>: <span class="string">&quot;apple&quot;</span>,</span><br><span class="line">          <span class="string">&quot;orange&quot;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">          <span class="literal">True</span>: <span class="literal">False</span>,</span><br><span class="line">          <span class="literal">None</span>: <span class="string">&quot;True&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pairs.get(<span class="string">&quot;orange&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(pairs.get(<span class="number">7</span>))</span><br><span class="line"><span class="built_in">print</span>(pairs.get(<span class="number">12345</span>, <span class="string">&quot;not in dictionary&quot;</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span> dictionary</span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul><li>元组很像列表，但是元组不能体用列表类能够提供给你的很多功能。元组的一大特征不可变的。</li><li>元组使用圆括号创建。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words = (<span class="string">&quot;spam&quot;</span>, <span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;sausages&quot;</span>,)</span><br></pre></td></tr></table></figure><ul><li>可以像访问列表一样，通过索引来访问元组。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(words[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li><p>给元组重新分配值会触发TypeError例外。</p></li><li><p>和列表字典一样，元组也能嵌套存储。</p></li><li><p>我们也可以不用圆括号就创建元组，通过逗号分割来确定元素的分组。</p></li><li><p>空元组必须通过圆括号创建。</p></li><li><p>尽管元组不能改变，但是运算速度快鱼列表。</p></li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_tuple[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One</span><br></pre></td></tr></table></figure><p>实例4空元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tpl = ()</span><br></pre></td></tr></table></figure><h2 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h2><h3 id="列表切片-1"><a href="#列表切片-1" class="headerlink" title="列表切片"></a>列表切片</h3><ul><li>Python为勒边提供了高级特性切片（Slice）操作功能，大大简化了获取一个列表区间的操作。切片操作通过两个索引数字中间用冒号分割来完成，返回从第一个数字索引到第二个数字索引的一个新列表。</li><li>和range函数操作一样，包含第一个数字索引里的值，不包含第二个数字索引的值。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squares = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="built_in">print</span>(squares[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(squares[<span class="number">3</span>:<span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(squares[<span class="number">0</span>:<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>]</span><br><span class="line">[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>如果切片的第一个数字忽略，切片操作从0开始，如果切片的第二个数字缺失，切片操作直到列表尾部结束。</li><li>切片操作同样作用于元组。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squares = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="built_in">print</span>(squares[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(squares[:<span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(squares[<span class="number">0</span>:<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>]</span><br><span class="line">[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>列表切片操作同样可以提供第三个参数，这一参数将被视为切片的步长（Step），在默认情况下，步长大小为 1.</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squares = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="built_in">print</span>(squares[::<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(squares[<span class="number">2</span>:<span class="number">8</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><ul><li>索引操作也可以使用负数，在这种情况下，位置计数将从列表的末尾开始。</li><li>如果步进使用负值，则切片操作将从后向前执行。</li><li>使用[ ::-1]切片是一种常见的方法来反转列表。</li></ul><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squares = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="built_in">print</span>(squares[<span class="number">1</span>:-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>]</span><br></pre></td></tr></table></figure><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><ul><li>列表生成式即List Comprehensions，是Python内置的非常强大却简单的可以用来创建列表的生成式。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a list comprehension</span></span><br><span class="line">cubes = [i ** <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(cubes)</span><br></pre></td></tr></table></figure><p>运算结果：    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>]</span><br></pre></td></tr></table></figure><ul><li>列表生成式同样可以包含if条件判断，一遍创建一个符合一定条件的列表。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">evens = [i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i**<span class="number">2</span> %<span class="number">2</span> ==<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(evens)</span><br></pre></td></tr></table></figure><p>运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>]</span><br></pre></td></tr></table></figure><ul><li>通过列表生成式生成一个非常大的列表会引发MemoryError异常。</li><li>这个问题我们通过迭代器来解决这个问题。</li></ul><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><h3 id="字符串格式化-1"><a href="#字符串格式化-1" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>我们经常会输出类似“亲爱的xxx你好！你XX月的话费是xx”之类的字符串，而xx的内容是根据变量变化的。</p><ul><li>所以，需要一种简便的格式化字符串的方式，string 对象提供了一个format的方法。</li><li>每一个参数对应字符串里相应的占位符{ }。使用数字的方式不仅可以交换参数的位置，甚至可以在字符串里面换位，比如{ 2 }在最前面。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># string formatting</span></span><br><span class="line">nums = [<span class="number">4</span>, <span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">msg = <span class="string">&quot;Numbers:&#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Numbers:<span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><ul><li>字符串格式化也可以用命名参数替换。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;&#123;x&#125;, &#123;y&#125;&quot;</span>.<span class="built_in">format</span>(x=<span class="number">5</span>, y=<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>, <span class="number">12</span></span><br></pre></td></tr></table></figure><ul><li>Python还提供了另外一种格式化的方法。这种格式化方式和C语言是一致的用 % 实现，</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;Hello, %s&#x27;</span> % <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">s=<span class="string">&#x27;Hi %s, you have $%d,&#x27;</span> % (<span class="string">&#x27;Michael&#x27;</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, world</span><br><span class="line">Hi Michael, you have $<span class="number">1000000</span>,</span><br></pre></td></tr></table></figure><ul><li>% 运算符就是用来格式化字符串的，下图是常见的占位符。</li></ul><table><thead><tr><th>格式</th><th>符号转换</th></tr></thead><tbody><tr><td>%c</td><td>字符</td></tr><tr><td>%s</td><td>通过str()字符串转换来格式化</td></tr><tr><td>%i</td><td>有符号十进制整数</td></tr><tr><td>%d</td><td>有符号十进制整数</td></tr><tr><td>%u</td><td>无符号十进制整数</td></tr><tr><td>%o</td><td>八进制整数</td></tr><tr><td>%x</td><td>十六进制整数（小写字母）</td></tr><tr><td>%X</td><td>十进制整数（大写字母）</td></tr><tr><td>%e</td><td>索引符号（小写‘e’）</td></tr><tr><td>%E</td><td>索引符号（大写’E’）</td></tr><tr><td>%f</td><td>浮点实数</td></tr><tr><td>%g</td><td>%f和%e的简写</td></tr><tr><td>%G</td><td>%f和%E的简写</td></tr><tr><td></td><td></td></tr></tbody></table><ul><li>在字符串内部，%s 表示用字符串替换，%d表示用整数替换，有几个%？占位符，<br>后面就跟几个变量或者值，顺序需要对应好。如果只有一个%？，括号可以省略。</li></ul><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><ul><li>Python标准库内建一些常用的方法。</li></ul><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>Join</td><td>用一个字符串作为分隔符连接字符串列表。</td></tr><tr><td>Replace</td><td>对字符串进行替换操作。</td></tr><tr><td>Startswith</td><td>字符串是否以另一个字符串开头。</td></tr><tr><td>Endswith</td><td>字符串是否以另一个字符串结束。</td></tr><tr><td>Upper 和lower</td><td>返回字符串以大写或小写的形式。</td></tr><tr><td>Split</td><td>切割字符串为列表。</td></tr></tbody></table><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>.jion([<span class="string">&quot;spam&quot;</span>, <span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;ham&quot;</span>]))</span><br><span class="line"><span class="comment">#prints &quot;spam, eggs, ham&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello ME&quot;</span>.replace(<span class="string">&quot;ME&quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"><span class="comment">#prints &quot;Hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This is a sentence&quot;</span>.startswith(<span class="string">&quot;This&quot;</span>))</span><br><span class="line"><span class="comment">#prints True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This is a sentence&quot;</span>.endswith(<span class="string">&quot;sentence&quot;</span>))</span><br><span class="line"><span class="comment">#prints True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This is a sentence&quot;</span>.upper())</span><br><span class="line"><span class="comment">#prints &quot;THIS IS A SENTENCE.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AN ALL CAPS SENTENCE&quot;</span>.lower())</span><br><span class="line"><span class="comment">#prints&quot;an all caps sentence&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;spam, eggs, ham&quot;</span>.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"><span class="comment">#prints &quot;[&#x27;spam&#x27;,&#x27;eggs&#x27;, &#x27;ham&#x27;]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h3><p>Max 和min 查找一组数里最大和最小的值。<br>Abs 绝对值<br>Round四舍五入<br>Sum数字列表里数字的总和。</p><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(-<span class="number">99</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(<span class="number">42</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure><p>列表方法</p><ul><li>标准库提供了一些非常有用的函数，all和any 函数为我们队列表进行条件判断提供了方便。函数 enumerate 也提供了另一种方式来遍历列表的方法。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">55</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">all</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All larger than 5&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">any</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;At least one is even&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="python2.jpg"></p><h2 id="文本分析"><a href="#文本分析" class="headerlink" title="文本分析"></a>文本分析</h2><p>例子：<br>分析文件里每个字母出现的百分比，首先我们打开一个文件并读取内容。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="built_in">input</span>(<span class="string">&quot;Enter a filename:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a filename:   filename.txt</span><br><span class="line">Some new text</span><br></pre></td></tr></table></figure><p>实例2:统计一个字母出现在文件的百分比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_char</span>(<span class="params">text, char</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> text:</span><br><span class="line">        <span class="keyword">if</span> c== char:</span><br><span class="line">            count +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">filename =<span class="built_in">input</span>(<span class="string">&quot;Enter a filename:&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span>  f:</span><br><span class="line">    text = f.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>:</span><br><span class="line">    perc = <span class="number">100</span> *count_char(text,char) / <span class="built_in">len</span>(text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;0&#125; - &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(char, <span class="built_in">round</span>(perc,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Enter a filename:filename.txt</span><br><span class="line">a - <span class="number">0.0</span></span><br><span class="line">b - <span class="number">0.0</span></span><br><span class="line">c - <span class="number">0.0</span></span><br><span class="line">d - <span class="number">0.0</span></span><br><span class="line">e - <span class="number">23.08</span></span><br><span class="line">f - <span class="number">0.0</span></span><br><span class="line">g - <span class="number">0.0</span></span><br><span class="line">h - <span class="number">0.0</span></span><br><span class="line">i - <span class="number">0.0</span></span><br><span class="line">j - <span class="number">0.0</span></span><br><span class="line">k - <span class="number">0.0</span></span><br><span class="line">l - <span class="number">0.0</span></span><br><span class="line">m - <span class="number">7.69</span></span><br><span class="line">n - <span class="number">7.69</span></span><br><span class="line">o - <span class="number">7.69</span></span><br><span class="line">p - <span class="number">0.0</span></span><br><span class="line">q - <span class="number">0.0</span></span><br><span class="line">r - <span class="number">0.0</span></span><br><span class="line">s - <span class="number">0.0</span></span><br><span class="line">t - <span class="number">15.38</span></span><br><span class="line">u - <span class="number">0.0</span></span><br><span class="line">v - <span class="number">0.0</span></span><br><span class="line">w - <span class="number">7.69</span></span><br><span class="line">x - <span class="number">7.69</span></span><br><span class="line">y - <span class="number">0.0</span></span><br><span class="line">z - <span class="number">0.0</span></span><br></pre></td></tr></table></figure><h1 id="函数式编程（陌生）"><a href="#函数式编程（陌生）" class="headerlink" title="函数式编程（陌生）"></a>函数式编程（陌生）</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="函数式编程-1"><a href="#函数式编程-1" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>函数式（Functional Programming）式一种以函数为基础的编程风格。</p><ul><li>函数编程的一个关键部分是高阶函数，高阶函数英文叫Higher-order function,在关于函数作为对象的一课中，我们简单地看到了这个想法的例子。高阶函数接受其他函数作为参数，甚至允许将函数作为结果返回。</li><li>一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数，函数式编程就是这种高度抽象的编程范式。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_twice</span> (func, arg):</span><br><span class="line">    <span class="keyword">return</span> func(func(arg))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_five</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(apply_twice(add_five, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><ul><li>纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入时确定的，输出就是确定的，这种纯函数称之为没有副作用。</li><li>非纯函数是因为返回的 结果是不固定的，上面的代码改变了列表some_list.。</li><li>纯函数的优缺点：</li></ul><ol><li>   容易推理和测试；</li><li>   能够并行运算</li><li>   更有效率。一旦对输入的函数进行求值，对于给定的参数结果都是固定的，既可以存储起来并在下次需要该函数时引用，从而减少调用该函数的次数。这叫记忆化（memolzation）。</li></ol><ul><li>使用纯函数的主要缺点是：它们使得IO的简单任务复杂化，这种任务本身就需要副作用，在一些情况下，纯函数可能更难编写。</li></ul><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul><li>我们学到的编写函数的方式是使用def 来创建函数，并指派一个def定义的变量名来调用。</li><li>在有些时候，不需要显式地定义函数，如果函数是使用lambada语法创建的，这种方式创建的函数称为“匿名函数”</li><li>该方法在不需要显式地定义函数时最常用。它由lambda关键字、参数列表、冒号、要计算和返回的表达式组成。</li><li>Lambda演算是Alonzo Chruch给出的一套图灵机等价的形式计算系统。Lambda演算系统的精妙之处在于处理递归，lambda演算也叫λ演算。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">f, arg</span>):</span><br><span class="line">    <span class="keyword">return</span> f(arg)</span><br><span class="line"></span><br><span class="line">my_func(<span class="keyword">lambda</span> x:<span class="number">2</span>*x*x, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">- Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数，通常是一个单行的代码来写一个表达式。</span><br><span class="line">- 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。</span><br><span class="line"></span><br><span class="line">实例<span class="number">2</span></span><br><span class="line">```python</span><br><span class="line"><span class="comment">#named function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">polynomia</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span> + <span class="number">5</span>*x + <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(polynomia(-<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#lambda</span></span><br><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> x: x**<span class="number">2</span> + <span class="number">5</span>*x +<span class="number">4</span>) (-<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用边浪来调用该函数。</li><li>最好还是用def来定义函数，可以把匿名函数作为返回值返回。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double = <span class="keyword">lambda</span>  x: x * <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(double(<span class="number">7</span>))</span><br></pre></td></tr></table></figure><p>运行结果：    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h2 id="Map和filter函数"><a href="#Map和filter函数" class="headerlink" title="Map和filter函数"></a>Map和filter函数</h2><h3 id="Map函数"><a href="#Map函数" class="headerlink" title="Map函数"></a>Map函数</h3><p>Python内建了map 和filter 高阶函数，它们接收一个iterable对象（比如：列表）。</p><p>Map函数接收两个参数，一个是函数，一个是iterable ，map将传入的函数依次作用到序列的每个元素，并把结果作为新的iterator返回。<br>例如有一个函数 f(x) &#x3D; x + 5，要把这个函数作用在一个列表[11,22,33,44,55]上，就可以用map实现。<br><img src="python3.jpg"> </p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_five</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line">result = <span class="built_in">list</span> (<span class="built_in">map</span>(add_five, nums))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">16</span>, <span class="number">27</span>, <span class="number">38</span>, <span class="number">49</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure><p>实例2<br>用匿名函数实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span>  x: x+<span class="number">5</span>, nums))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">16</span>, <span class="number">27</span>, <span class="number">38</span>, <span class="number">49</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure><ul><li>Map函数返回的是一个iterator ，是一个惰性序列，所以要强迫filter完成计算结果，需要用list 函数强制转换成列表。</li></ul><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><ul><li>Python内建的filter函数用于过滤序列，给定的函数返回Boolean 值，根据返回值是True还是False决定保留还是丢弃该元素。</li><li>Filter函数返回的是一个iterator 需要用list函数强制转换成列表。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span>  x: x %<span class="number">2</span>==<span class="number">0</span>, nums))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">22</span>, <span class="number">44</span>]</span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p> 在前面的课程，可以直接创建一个列表。但受到内存限制，列表容量肯定是有限的，如果我们仅仅需要访问大列表里的几个元素，绝大多数元素占用的空间都白白浪费了。<br>如果列表元素可以按照某种算法推算出来，那么就有可能不用这么大的内存，</p><ul><li>在Python中，这种一边循环一边计算的机制，称为生成器（generator）。生成器是一种像列表和元组的 iterable。</li><li>与列表不同，它们不允许使用索引进行索引，但仍然可以使用for 循环进行遍历，语法yield用来生成生成器。</li><li>Yield 语句用于定义生成器，将函数的返回值替换为向调用者提供结果而不破坏本地变量。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>():</span><br><span class="line">    i=<span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> countdown():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>由于每次生成一个数据，生成器没有了列表的内存限制，可以无穷调用：</li><li>简而言之，生成器允许您声明一个类似迭代器的函数，可以在for循环中使用。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">infinite_sevens</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span>  <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> infinite_sevens():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span>                      一堆 的<span class="number">7</span>（死循环）</span><br></pre></td></tr></table></figure><ul><li>生成器作为list函数的参数以使用它生成列表。</li><li>由于具有延迟并按需生成值的特性，使用生成器可以提高性能，也会降低内存的开销，另外，不需要等到所有元素生成之后才开始使用它们。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numbers</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(numbers(<span class="number">11</span>)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在代码运行期间动态增加功能的方式，称之为装饰器（Decorator）。<br>当需要扩展一些功能，但是不想修改代码，就可以用装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decor</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=============================&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=============================&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_text</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line"></span><br><span class="line">decorated = decor(print_text)</span><br><span class="line">decorated()</span><br></pre></td></tr></table></figure><p>上面例子定义了一个décor函数接收一个加func的函数，在函数décor里面我们定义了一个函数wrap，函数wrap打印一些字符串并调用函数func。函数décor返回函数wrap。我们使用decorated 来装饰print_text函数，让其添加一些功能。</p><ul><li>本质上，装饰器就是一个返回函数的高阶函数。所以，要定义一个能打印日志的装饰器，可以定义如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func._name_)</span><br><span class="line">        <span class="keyword">return</span> func(*args,  **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>函数对象有一个_name_属性，可以取到函数的名字。</li><li>一个装饰器接收一个函数作为参数，并返回一个函数。先前的例子我们使用装饰器修改了print_text 函数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_text</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">print_text = decor(print_text)</span><br></pre></td></tr></table></figure></li><li>如果我们需要一个模式可以在任何时间使用装饰器修改一个函数，那么要借助Python的@语法，把装饰器函数置于函数的定义处。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decor</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_text</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>一个含税可以有多个装饰器。</li></ul><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><ul><li>如果一个函数在内部调用自身，这个函数就是递归函数。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">x</span>):         <span class="comment">#    n!的计算</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span>  x *factorial(x-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(factorial(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><ul><li>使用递归函数需要关注如何退出递归。</li><li>在计算机中，函数调用时通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出导致程序崩溃。</li><li>解决递归调用栈溢出的方法可以通过尾递归优化。</li><li>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释其就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。<br>上面的函数由于引入了乘法表达式，所以就不是尾递归。要改成尾递归，需要多一点代码：</li></ul><p>实例2（重点）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):         <span class="comment">#    n!的计算</span></span><br><span class="line">    <span class="keyword">return</span> fact(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">num, product</span>):</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact(num - <span class="number">1</span>, num *product)</span><br><span class="line"><span class="built_in">print</span>(factorial(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p>大多数编程员设计没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的factorial 函数改为尾递归方式，也会导致栈溢出。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h3><ul><li>集合（set）是一种数据结构和字典类似，也是一组key的集合，但不存储value。</li><li>创建集合有两种方式：使用列表作为参数的set函数   或者是  使用语法{}创建。</li><li>创建一个空set 必须使用set 函数，使用{}会创建字典。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">word_set = <span class="built_in">set</span>([<span class="string">&quot;spam&quot;</span>, <span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;sausage&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> num_set)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;spam&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> word_set)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>集合与列表有几种不同之处，但是他们都可以用len操作</li><li>集合是无序的，这意味着他们不能被索引，在集合中也没有重复的key。</li><li>由于采用不同的数据结构，集合的in操作里比列表更快，使用add 添加元素，使用remove删除特定的元素，pop删除任意一个函数。</li><li>集合的基本用途包括元素存在测试和消除重复元素。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line">nums.add(-<span class="number">7</span>)</span><br><span class="line">nums.remove(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, -<span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>集合能使用一些数字概念上的操作。</li></ul><table><thead><tr><th>操作符</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>并集操作符</td><td>|</td><td>合并两个集合</td></tr><tr><td>交集操作符</td><td>&amp;</td><td>返回两个集合都存在的元素</td></tr><tr><td>补集操作符</td><td>-</td><td>返回元素在第一个集合，但是不在第二个集合。</td></tr><tr><td>对称差集操作符</td><td>^</td><td>返回不在两个集合中都存在的元素。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">first = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">second = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(first   |  second)</span><br><span class="line"><span class="built_in">print</span>(first   &amp;  second)</span><br><span class="line"><span class="built_in">print</span>(first   -  second)</span><br><span class="line"><span class="built_in">print</span>(second  -  first)</span><br><span class="line"><span class="built_in">print</span>(first   ^  second)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>先前的课程看到Python拥有下面的 数据结构：list（列表），字典（dictionary）、元组（tuple）、集合（set）。</p><ul><li>当需要唯一的元素，使用集合。</li><li>当需要数据不能修改，使用元组。</li><li>当需要一个简单的，可迭代的，经常修改的集合时，或需要有序访问，请尝试选择列表。</li><li>使用字典的情况：<br>需要一种key_value的这种逻辑；<br>需要一种通过key快速查找数据的方法；<br>需要经常修改数据‘</li><li>很多时候，元组与字典会结合使用，例如：元组可能代表一个键，因为它是不可变的。</li></ul><h2 id="Itertools模块"><a href="#Itertools模块" class="headerlink" title="Itertools模块"></a>Itertools模块</h2><p>Python的内建模块IT而tools提供了在函数式编程里非常有用的用于操作迭代对象的函数。</p><ul><li>无限迭代器：count一个计数器，可以指定起始位置和步长。<br>Cycle会把传入的一个序列（列表或字符串）无限重复下去。<br>Repeat把一个元素无限重复下去，如果提供第二个参数就可以限定重复次数。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i &gt;=<span class="number">11</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><p>Itertools模块包含很多函数处理iterator对象，就像map和filter函数一样。</p><ul><li>有限迭代器：</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Takewhile</td><td>函数根据条件判断来获取序列；</td></tr><tr><td>Chain</td><td>把一组迭代对象串联起来，形成一个更大的迭代器。</td></tr><tr><td>Accumulate</td><td>迭代器返回累计求和结果。</td></tr></tbody></table><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate, takewhile</span><br><span class="line"></span><br><span class="line">nums = <span class="built_in">list</span>(accumulate(<span class="built_in">range</span>(<span class="number">8</span>)))</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(takewhile(<span class="keyword">lambda</span> x: x&lt;=<span class="number">6</span>, nums)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><ul><li>组合生成器：</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Product</td><td>产生多个列表和迭代器的笛卡尔积</td></tr><tr><td>Permutation</td><td>产生指定数目的元素的所有排列。</td></tr></tbody></table><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product,permutations</span><br><span class="line"></span><br><span class="line">letters = (<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(product(letters, <span class="built_in">range</span>(<span class="number">2</span>))))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(permutations(letters)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">&#x27;A&#x27;</span>, <span class="number">0</span>), (<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="number">0</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">[(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)]</span><br></pre></td></tr></table></figure><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="类（有些懵）"><a href="#类（有些懵）" class="headerlink" title="类（有些懵）"></a>类（有些懵）</h2><p>先前我们研究过两种编程范式——命令式（使用语句、循环和函数）和函数（使用纯函数、高阶函数和递归）。</p><ul><li>接下来学习一种编程方式是面向对象编程——Object Oriented Programming，简称OOP，这是一种程序设计思想。OOP把对象称为程序的基本单元，类描述对象将是什么，一个对象包含了数据和操作数据的函数。</li></ul><p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p><p>面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息并处理这些消息。计算机程序的执行就是一系列消息在各个对象之间传递。</p><p>类是使用关键字class 和缩进块创建的，缩进块包含类方法（这些是函数）</p><ul><li>数据封装、继承和多态是面向对象的三大特点。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, color, legs</span>):</span><br><span class="line">        self.color =color</span><br><span class="line">        self.legs =legs</span><br><span class="line"></span><br><span class="line">feilx = Cat(<span class="string">&quot;ginger&quot;</span>,<span class="number">4</span>)</span><br><span class="line">rover = Cat(<span class="string">&quot;dog-colored&quot;</span>,<span class="number">4</span>)</span><br><span class="line">stumpy = Cat(<span class="string">&quot;brown&quot;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="init-方法"><a href="#init-方法" class="headerlink" title="_init_方法"></a>_init_方法</h3><p>_init_方法是类中比较重要的方法，在创建类的实例（对象）时调用，这种方法创建的属性称为实例变量。</p><p>类中所有方法都必须将self 作为他们的第一个参数，尽管它没有显式传递，但Python将self 参数添加到列表中。在调用方法时不需要包含它。在方法定义中，self 引用调用该方法的实例。类的实例具有属性，这些属性是与实例关联的数据。</p><p>在下实例中，Cat实例将具有color 和legs 的属性，可以通过实例后面加点和属性名来访问这些值。同样，在_init_方法中，可以使用self.attribute来设置实例属性的初始值。</p><ul><li>特殊方法 _init_前后分别有两个下划线！</li><li>在下面的示例中，_init_方法接受两个参数，并将他们分配给对象的属性。_init_方法称为类构造函数。</li></ul><p>实例2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, color, legs</span>):</span><br><span class="line">        self.color =color</span><br><span class="line">        self.legs =legs</span><br><span class="line"></span><br><span class="line">felix = Cat(<span class="string">&quot;ginger&quot;</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(felix.color)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ginger</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>类可以定义其他方法用来添加一些功能。请记住，所有方法都必须将self 作为他们的第一个参数。使用与点加属性的语法来访问这些方法。</li><li>类属性一种是通过_init_方法来定义，也可以自己直接定义类属性，这种属性叫它类变量。是通过在类的主体内分配变量创建的。可以从类的实例或类本身访问它们。</li><li>类变量由类的所有实例共享。</li></ul><p>实例3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, color, legs</span>):</span><br><span class="line">        self.color =color</span><br><span class="line">        self.legs =legs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Woof!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">felix = Cat(<span class="string">&quot;ginger&quot;</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(felix.color)</span><br><span class="line">felix.bark()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ginger</span><br><span class="line">Woof!</span><br></pre></td></tr></table></figure><p>实例4:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    legs = <span class="number">4</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, color</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.color =color</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fido = Dog(<span class="string">&quot;Fido&quot;</span>,<span class="string">&quot;brown&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fido.legs)</span><br><span class="line"><span class="built_in">print</span>(Dog.legs)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><ul><li>通过在两个类中共享函数实现继承。<br>对于例题中 cat，dog，尽管它们有一些不同，但它们都有颜色，名字。<br>这些相同点可以通过继承父类Animal 来实现这些共享的属性和方法。</li><li>继承最大的好处是子类获得了父类的全部功能。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name, color</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">purr</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Purr……&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Woof!&quot;</span>)</span><br><span class="line"></span><br><span class="line">fido = Dog(<span class="string">&quot;Fido&quot;</span>,<span class="string">&quot;brown&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fido.color)</span><br><span class="line">fido.bark()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brown</span><br><span class="line">Woof!</span><br></pre></td></tr></table></figure><ul><li>在OOP程序设计中，当我们定义一个class 的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的类称为基类、父类或者超类（Base class、 Super class）</li><li>如果一个子类拥有一个和父类相同的属性或方法，称为重写（override）。在代码运行的时候，总是会调用子类的方法。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name, color</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Grr…&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Wolf</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Woof&quot;</span>)</span><br><span class="line"></span><br><span class="line">husky = Dog(<span class="string">&quot;Max&quot;</span>,<span class="string">&quot;grey&quot;</span>)</span><br><span class="line">husky.bark()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Woof</span><br></pre></td></tr></table></figure><p>上面例子中 Wolf 是父类，Dog是子类。</p><ul><li>子类同样可以作为父类被继承，这样继承的子类拥有两个父类的方法和属性</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">methon</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">another_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">B</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">third_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C method&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.methon()</span><br><span class="line">c.another_method()</span><br><span class="line">c.third_method()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A method</span><br><span class="line">B method</span><br><span class="line">C method</span><br></pre></td></tr></table></figure><ul><li>方法 super 用来在子类中代指父类，可以用于在实例的父类中找到具有特定名称的方法。</li></ul><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">super</span>().spam()</span><br><span class="line"></span><br><span class="line">B().spam()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>super（）.spam()调用父类的spam方法。</p><h2 id="内部方法和操作符重载"><a href="#内部方法和操作符重载" class="headerlink" title="内部方法和操作符重载"></a>内部方法和操作符重载</h2><h3 id="秘密的方法（不理解）"><a href="#秘密的方法（不理解）" class="headerlink" title="秘密的方法（不理解）"></a>秘密的方法（不理解）</h3><p>Python中有一些特殊的方法，也就是以双下划綫开头，并且以双下划线结尾的。可以是变量如 __doc__，也可以是方法如 __init__。<br>它们常见用途是操作符重载。这意味着在自定义类定义操作符，允许在这些类上使用加减乘除等运算符。其中一个方法是用__add__来做为加法运算符。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector2D</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Vector2D(self.x + other.x, self.y + other.y)</span><br><span class="line"></span><br><span class="line">first = Vector2D(<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line">second = Vector2D(<span class="number">3</span>,<span class="number">9</span>)</span><br><span class="line">result = first + second</span><br><span class="line"><span class="built_in">print</span>(result.x)</span><br><span class="line"><span class="built_in">print</span>(result.y)</span><br></pre></td></tr></table></figure><p>运算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> </span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>上面例子通过定义 __add__方法来处理类之间假发的运算。返回里一个对象包含运算结果。</p><ul><li>运算方面的方法：</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>sub</strong></td><td>表示运算符   –</td></tr><tr><td><strong>mul</strong></td><td>表示运算符   *</td></tr><tr><td><strong>truediv</strong></td><td>表示运算符   &#x2F;</td></tr><tr><td><strong>floordiv</strong></td><td>表示运算符   &#x2F;&#x2F;</td></tr><tr><td><strong>mod</strong></td><td>表示运算符   %</td></tr><tr><td><strong>pow</strong></td><td>表示运算符   **</td></tr><tr><td><strong>and</strong></td><td>表示运算符   &amp;</td></tr><tr><td><em>xor</em>_</td><td>表示运算符   ^</td></tr><tr><td><strong>or</strong></td><td>表示运算符    |</td></tr></tbody></table><p>表达式 x+y 会被Python转换成x.__add__（y）。<br>但是如果x没有实现__add__方法并且x 和 y 是不同的类型，那么会调用y.<strong>radd</strong>(x)。<br>对于上面提到的所有方法，都有相等的 r 方法！！！？？？？？<br>不理解！！！！</p><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialString</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cont</span>):</span><br><span class="line">        self.cont = cont</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__truediv__</span>(<span class="params">self, other</span>):</span><br><span class="line">        line = <span class="string">&quot;=&quot;</span> * <span class="built_in">len</span>(other.cont)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join([self.cont, line, other.cont])</span><br><span class="line"></span><br><span class="line">spam = SpecialString(<span class="string">&quot;spam&quot;</span>)</span><br><span class="line">hello = SpecialString(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(spam / hello)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spam</span><br><span class="line">============</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure><p>上面我们定义了类 SpecialString的一个除法的方法。</p><ul><li>Python同样提供了数据比较方面的方法。</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>lt</strong></td><td>表示运算符&lt;</td></tr><tr><td><strong>le</strong></td><td>表示运算符&lt;&#x3D;</td></tr><tr><td><strong>eq</strong></td><td>表示运算符&#x3D;&#x3D;</td></tr><tr><td><strong>ne</strong></td><td>表示运算符!&#x3D;</td></tr><tr><td><strong>gt</strong></td><td>表示运算符&gt;</td></tr><tr><td><em>ge</em>_</td><td>表示运算符&gt;&#x3D;</td></tr></tbody></table><p>如果类没有实现 __ne__，则返回__eq__相反的值。其他运算符之间没有关系。</p><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialString</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cont</span>):</span><br><span class="line">        self.cont = cont</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(other.cont)+ <span class="number">1</span>):</span><br><span class="line">            result = other.cont[:index] + <span class="string">&quot;&gt;&quot;</span> + self.cont</span><br><span class="line">            result += <span class="string">&quot;&gt;&quot;</span> + other.cont[index:]</span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line">spam = SpecialString(<span class="string">&quot;spam&quot;</span>)</span><br><span class="line">eggs = SpecialString(<span class="string">&quot;eggs&quot;</span>)</span><br><span class="line">spam &gt; eggs</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;spam&gt;eggs</span><br><span class="line">e&gt;spam&gt;ggs</span><br><span class="line">eg&gt;spam&gt;gs</span><br><span class="line">egg&gt;spam&gt;s</span><br><span class="line">eggs&gt;spam&gt;</span><br></pre></td></tr></table></figure><ul><li>类中还有一些方法：</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>len</strong></td><td>可用来做len（）</td></tr><tr><td><strong>getitem</strong></td><td>可用来做键值读取，适用于[]运算符。</td></tr><tr><td><strong>setitem</strong></td><td>设置给定键的值</td></tr><tr><td><strong>delitem</strong></td><td>删除给定键对应的元素</td></tr><tr><td><strong>iter</strong></td><td>用来遍历对象</td></tr><tr><td><strong>contains</strong></td><td>可用来做in 操作</td></tr></tbody></table><p>还有许多其他的神奇的方法，例如 __call__用来将对象作为函数调用，__int__，__str__等等用于将对象转换为Python基础数据类型。</p><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VagueList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cont</span>):</span><br><span class="line">        self.cont =cont</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.cont[index + random.randint(-<span class="number">1</span>,<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> random.randint(<span class="number">0</span>, <span class="built_in">len</span>(self.cont)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">vague_list = VagueList([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(vague_list))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(vague_list))</span><br><span class="line"><span class="built_in">print</span>(vague_list[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(vague_list[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>实例5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>表达式x[y] = z 调用时，下面哪个方法被调用？</span><br><span class="line">A．y.__getitem__(x,z)</span><br><span class="line">B  x.__setitem__(y,z)</span><br><span class="line">C  x.setitem(z,y)</span><br><span class="line"></span><br><span class="line">答案：B</span><br></pre></td></tr></table></figure><p>实例6</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>下面哪个方法等同于如果A没有实现^的方法？</span><br><span class="line">A．B（）.xor(A())</span><br><span class="line">B．B().__rxor__(A())</span><br><span class="line">C．A(.)__xor__(B())</span><br><span class="line"></span><br><span class="line">答案：B</span><br></pre></td></tr></table></figure><h2 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h2><ul><li>一个对象会经历三个生命周期：创建，操作，销毁。</li><li>对象生命周期的第一个阶段是它类变量和方法的定义。<br>接下来下一阶段是这个实例的实例化。当 __init__被调用时，内存分配给存储实例。在此之前，调用类的__new__方法，这通常仅在特殊情况下会被重写。在此之后，该对象就可以使用了。</li><li>现在，其他代码可以通过调用对象上的函数并访问其属性与对象进行交互。最后它将被使用完毕，并可被销毁。</li><li>当一个对象被销毁时，分配给它的内存会被释放，并可以用于其他目的。<br>当对象的引用计数达到零时，对象将被销毁。引用计数是指引用对象的变量和其他元素的数量。如果没有任何变量引用它（它的引用计数为零），意味着没有任何东西可以与其交互，因此可以安全地删除它。在某些情况下，只有两个（或更多）对象相互引用，因此也可以被删除。Del 语句将对象的引用计数减少一个。这通常会导致对象被删除。Del 语句调用对象的方法__del__。</li></ul><p>在不再需要对象时删除对象的过程称为垃圾收集。对象的引用计数在分配新名称或放在容器（列表、元组或字典）中时会增加。当使用del 删除对象时，对象的引用计数会减少。当对象的引用计数达到零时，Python会自动删除它。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">42</span>   <span class="comment">#  Create object&lt;42&gt;</span></span><br><span class="line">b = a    <span class="comment">#  Increase ref.count of &lt;42&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a    <span class="comment"># Decrease ref.count of &lt;42&gt;</span></span><br><span class="line">b=<span class="number">100</span>    <span class="comment"># Decrease ref.count of&lt;42&gt;</span></span><br><span class="line">c[<span class="number">0</span>] = -<span class="number">1</span> <span class="comment"># Decrease ref.count of &lt;42&gt;</span></span><br></pre></td></tr></table></figure><p>上面的例子，创建了一个含42的对象，对象的计数器加了3次，然后对象的计数器减少了三次。这时，该对象会被自动内存管理销毁。<br>像C这样的地基语言没有这种自动内存管理系统。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__del__是在哪个方法被调用？</span><br><span class="line">A  Class.<span class="keyword">del</span>(instance)</span><br><span class="line">B   instance.<span class="keyword">del</span></span><br><span class="line">C   <span class="keyword">del</span> instance</span><br><span class="line">答案：    C</span><br></pre></td></tr></table></figure><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><ul><li><p>面向对象编程的一个关键部分是封装，它涉及将相关变量和函数打包到一个简单易用的对象（类的一个实例）中。</p></li><li><p>一个相关的概念是隐藏数据，它隐藏了类的实现细节，并提供了一个干净的标准接口。</p></li><li><p>在其他编程语言中，通常是通过私有方法和属性完成的。这些方法和属性阻止了对类中某些方法和属性的外部访问。</p></li><li><p>Python的哲学略有不同。他任务“我们都是成年人”，这意味着你不应该对类的访问设置任意的限制。因此，没有任何方法强制方法或属性是严格私有的。</p></li><li><p>但是，还是有些方法可以阻止人们访问类的内部私有成员。</p></li><li><p>Python的私有方法是不鼓励外部代码使用的方法。</p></li><li><p>若私有方法和属性在开头只有一个下划线。</p></li></ul><p>这表明它们是私有的，不应该被外部代码使用。但是，它基本上只是一个约定，并不阻止外部代码访问它们。<br>它唯一的实际效果是，从模块导入from module_name import* 不会导入以单个下划线开头的变量。</p><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,contents</span>):</span><br><span class="line">        self._hiddenlist = <span class="built_in">list</span>(contents)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._hiddenlist.insert(<span class="number">0</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._hiddenlist.pop(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Queue(&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(self._hiddenlist)</span><br><span class="line"></span><br><span class="line">queue = Queue([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(queue)</span><br><span class="line">queue.push(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(queue)</span><br><span class="line">queue.pop()</span><br><span class="line"><span class="built_in">print</span>(queue)</span><br><span class="line"><span class="built_in">print</span>(queue._hiddenlist)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">Queue([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">Queue([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>上面的例子，属性_hiddenlist_标记为私有，但是还是可以被外部代码访问。</p><p>_repr_方法用来返回类用字符串来表现的形式。</p><ul><li>强私有方法和属性的名称开头有双下划线，这意味着它们不能从类之外被访问。</li></ul><p>这样做的目的并不是确保它们是私有的，而是如果有具有相同名称的方法或属性的子类，则可以避免bug。</p><p>使用这种方法直接访问时无法访问的，但可以通过不同的名称访问。Spam 类的私有方法_privatementod可以通过 _Spam_privatemethod 方法进行外部访问。</p><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    __egg = <span class="number">7</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_egg</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="built_in">print</span>(self.__egg)</span><br><span class="line"></span><br><span class="line">s = Spam()</span><br><span class="line">s.print_egg()</span><br><span class="line"><span class="built_in">print</span>(s._spam__egg)</span><br><span class="line"><span class="built_in">print</span>(s.__egg)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">AttributeError: <span class="string">&#x27;Spam&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;_spam__egg&#x27;</span></span><br></pre></td></tr></table></figure><p>实际运行结果（请重新验证代码！！！）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/System/untitled/hello.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(s._spam__egg)</span><br><span class="line">AttributeError: <span class="string">&#x27;Spam&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;_spam__egg&#x27;</span></span><br></pre></td></tr></table></figure><p>基本上，Python通过内部更改名称以包含类名来保护这些成员。</p><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">怎样在外部访问类b的私有属性__a?</span><br><span class="line">答： _b__a</span><br></pre></td></tr></table></figure><h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>到目前为止，所看到调用对象的方法都是由类的一个实例调用的，然后被传递给方法的self 参数。<br>类方法是不同的 –它们由一个类调用，该类被传递给方法的cls参数。<br>这些方法的常见用法是工厂方法，它们使用与传递给类构造函数的参数不同的参数来实例化实例。<br>类方法被装饰符@classmethod 标记为类方法。</p><p>实例1:（不理解）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, width, height</span>):</span><br><span class="line">        self.width = width</span><br><span class="line">        self.height =height</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.width * self.height</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_square</span>(<span class="params">cls, side_length</span>):</span><br><span class="line">        <span class="keyword">return</span> cls(side_length, side_length)</span><br><span class="line"></span><br><span class="line">square = Rectangle.new_square(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(square.calculate_area())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><ul><li>New_square是类方法，它不在类的实例上调用。而是通过类的方法调用，它返回类cls 的一个新对象。</li><li>从技术上讲，self和cls参数只是约定；它们可以更改为其他任何东西。但是，这种约定被大多数人遵循。</li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法与类方法相似，只是没有任何附加参数比如cls 和self。它们与属于类函数的使用方法相同。它们被静态方法装饰器@staticmethod 定义。</p><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, toppings</span>):</span><br><span class="line">        self.toppings = toppings</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate_topping</span>(<span class="params">topping</span>):</span><br><span class="line">        <span class="keyword">if</span> topping == <span class="string">&quot;pineapple&quot;</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;No pineapples!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">ingredients = [<span class="string">&quot;cheese&quot;</span>,<span class="string">&quot;onoons&quot;</span>,<span class="string">&quot;spam&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">all</span>(Pizza.validate_topping(i) <span class="keyword">for</span> i <span class="keyword">in</span> ingredients):</span><br><span class="line">    pizza = Pizza(ingredients)</span><br></pre></td></tr></table></figure><p>静态方法的行为类似于普通函数，除了不可以从类的实例中调用它们。</p><h2 id="属性函数"><a href="#属性函数" class="headerlink" title="属性函数"></a>属性函数</h2><p>属性函数提供一种定制化的访问属性的方法<br>有些时候我们不想让外界修改属性值，那么通过将属性装饰器@property 放在方法的上方创建属性函数。这意味着当访问与方法同名的实例属性时，将调用该方法。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, toppings</span>):</span><br><span class="line">        self.toppings = toppings</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pineapple_allowed</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">pizza = Pizza([<span class="string">&quot;cheese&quot;</span>,<span class="string">&quot;tomato&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(pizza.pineapple_allowed)</span><br><span class="line">pizza.pinapple_allowed = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>属性函数同样可以使用 setter&#x2F;getter 设置读写方法。</li><li>Setter函数定义设置属性的值。Getter 函数定义获取属性的值。</li><li>要定义获取属性值的函数，使用属性名后面跟着 .setter关键词，同样 .getter定义了这个方法属于获取属性值的函数。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, toppings</span>):</span><br><span class="line">        self.toppings = toppings</span><br><span class="line">        self._pineapple_allowed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pineapple_allowed</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._pineapple_allowed</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pineapple_allowed.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pineapple_allowed</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value:</span><br><span class="line">            password = <span class="built_in">input</span>(<span class="string">&quot;Enter the password:&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">                self._pineapple_allowed = value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;Alert! intruder!&quot;</span>)</span><br><span class="line">pizza = Pizza([<span class="string">&quot;cheese&quot;</span>,<span class="string">&quot;tomato&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(pizza.pineapple_allowed)</span><br><span class="line">pizza.pineapple_allowed = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(pizza.pineapple_allowed)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line">Enter the password:<span class="number">123456</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">写出定义一个egg属性的setter的装饰器。</span><br><span class="line"><span class="meta">@egg.setter</span></span><br></pre></td></tr></table></figure><h2 id="简单游戏"><a href="#简单游戏" class="headerlink" title="简单游戏"></a>简单游戏</h2><p>在管理不同的对象及其关系时，面向对象是非常有用的。当您正在开发具有不同特性和功能的游戏时，这一点尤其有用。</p><p>下面这个示例，展示了类在游戏开发中的用法，这款游戏是一款老式的基于文本的冒险游戏。下面是处理输入和简单解析的函数。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_input</span>():</span><br><span class="line">    command = <span class="built_in">input</span>(<span class="string">&quot;:&quot;</span>).split()</span><br><span class="line">    verb_word = command[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> verb_word <span class="keyword">in</span> verb_dict:</span><br><span class="line">        verb = verb_dict[verb_word]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Unknow verb&#123;&#125;&quot;</span>.<span class="built_in">format</span>(verb_word))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(command) &gt;= <span class="number">2</span>:</span><br><span class="line">        noun_word = command[<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(verb(noun_word ))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(verb(<span class="string">&quot;nothing&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">noun</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;You said &quot;&#123;&#125;&quot;&#x27;</span>.<span class="built_in">format</span>(noun)</span><br><span class="line">verb_dict = &#123;</span><br><span class="line">    <span class="string">&quot;say&quot;</span>:say,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    get_input()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:say Hello!</span><br><span class="line">You said <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">:say Goodbye!</span><br><span class="line">You said <span class="string">&quot;Goodbye!&quot;</span></span><br><span class="line">:test</span><br><span class="line">Unknow verbtest</span><br></pre></td></tr></table></figure><p>上面的代码接受用户的输入，并尝试将第一个单词与verb_dict中的命令匹配。如果找到匹配，则调用相应的函数。</p><ul><li>在输入上调用split 方法的作用是：将输入拆分为单词！</li></ul><p>下一步我们使用类来表示游戏对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameObject</span>:</span><br><span class="line">    class_name = <span class="string">&quot;&quot;</span></span><br><span class="line">    desc = <span class="string">&quot;&quot;</span></span><br><span class="line">    objects = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        GameObject.objects[self.class_name] =self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_desc</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.class_name + <span class="string">&quot;\n&quot;</span> + self.desc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goblin</span>(<span class="title class_ inherited__">GameObject</span>):</span><br><span class="line">    class_name =  <span class="string">&quot;goblin&quot;</span></span><br><span class="line">    desc = <span class="string">&quot;A foul creature&quot;</span></span><br><span class="line"></span><br><span class="line">goblin = Goblin(<span class="string">&quot;Gobbly&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">examine</span>(<span class="params">noun</span>):</span><br><span class="line">    <span class="keyword">if</span> noun <span class="keyword">in</span> GameObject.objects:</span><br><span class="line">        <span class="keyword">return</span> GameObject.objects[noun].get_desc()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;There is no &#123;&#125; here.&quot;</span>.<span class="built_in">format</span>(noun)</span><br></pre></td></tr></table></figure><p>我么创建了Goblin类，此类继承了G澳门Objects类。同时我们创建了一个新函数examine，它返回对象的描述信息。现在，我们可以在字典verb_dict中添加一个新的examine函数指向并使用它！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verb_dict = &#123;</span><br><span class="line">    <span class="string">&quot;say&quot;</span>:say,</span><br><span class="line">    <span class="string">&quot;examine&quot;</span>:examine,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将此代码与前面示例中的代码结合起来运行该程序。<br>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">：say Hello!</span><br><span class="line">You said “Hello!”</span><br><span class="line">:examine goblin</span><br><span class="line">Goblin</span><br><span class="line">A foul creature</span><br><span class="line">:examine elf</span><br><span class="line">There <span class="keyword">is</span> no elf here.</span><br></pre></td></tr></table></figure><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么Goblin要从GameObject 继承？</span><br><span class="line">答：Goblin是GameObject的一种。</span><br></pre></td></tr></table></figure><p>下面代码为类Goblin添加了更多的函数，并允许你与妖精开始战斗游戏。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gobline</span>(<span class="title class_ inherited__">GameObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.class_name = <span class="string">&quot;goblin&quot;</span></span><br><span class="line">        self.health = <span class="number">3</span></span><br><span class="line">        self.desc = <span class="string">&quot;A foul creature&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @peoperty</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">desc</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.health &gt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> self._desc</span><br><span class="line">        <span class="keyword">elif</span> self.health == <span class="number">2</span>:</span><br><span class="line">            health_line = <span class="string">&quot;It has a wound on its knee.&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> self.health ==<span class="number">1</span>:</span><br><span class="line">            health_line = <span class="string">&quot;Its left arm has been cut off!&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> self.health &lt;=<span class="number">0</span>:</span><br><span class="line">            health_line = <span class="string">&quot;It is dead.&quot;</span></span><br><span class="line">            <span class="keyword">return</span> self._desc + <span class="string">&quot;\n&quot;</span> + health_line</span><br><span class="line"></span><br><span class="line"><span class="meta">    @desc.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">desc</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._desc = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hit</span>(<span class="params">noun</span>):</span><br><span class="line">    <span class="keyword">if</span> noun <span class="keyword">in</span> GameObject.objects:</span><br><span class="line">        thing = GameObject.objects[noun]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(thing) == Goblin:</span><br><span class="line">            thing.health = thing.health - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> thing.health &lt;= <span class="number">0</span>:</span><br><span class="line">                msg = <span class="string">&quot;You kiled the goblin!&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                msg = <span class="string">&quot;You hit the &#123;&#125;&quot;</span>.<span class="built_in">format</span>(thing.class_name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        msg = <span class="string">&quot;There is no &#123;&#125;here.&quot;</span>.<span class="built_in">format</span>(noun)</span><br><span class="line">        <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="python4.jpg"> </p><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么把desc 编程一个属性？</span><br><span class="line">答：因为需要访问时可以动态地创建它。</span><br></pre></td></tr></table></figure><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性如何创建?</span><br><span class="line">使用属性装饰符@<span class="built_in">property</span></span><br></pre></td></tr></table></figure><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类方法和静态方法有什么不同？</span><br><span class="line">答：类方法调用时会把类为参数传进去，而静态方法不传</span><br></pre></td></tr></table></figure><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用实例和调用类的常用参数名称是什么？</span><br><span class="line">答：Self 和cls</span><br></pre></td></tr></table></figure><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在实例化对象之前调用什么方法？</span><br><span class="line">答：__init__</span><br></pre></td></tr></table></figure><p>实例5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使egg为强私有属性并从类外部访问它。</span><br><span class="line">Class Test:</span><br><span class="line">__egg = <span class="number">7</span>    <span class="comment">#记得前面是两个下划线</span></span><br><span class="line"></span><br><span class="line">T =Test（）</span><br><span class="line">Print(t._Test__egg)   <span class="comment">#记得Test前面有一个下划线，而egg前面有两个！！！考点！！！</span></span><br></pre></td></tr></table></figure><p>实例6</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">请完成name属性的setter函数</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">self._name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">@name.setter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self, value</span>):</span><br><span class="line">self._name = value</span><br></pre></td></tr></table></figure><h1 id="正则表达式（陌生）"><a href="#正则表达式（陌生）" class="headerlink" title="正则表达式（陌生）"></a>正则表达式（陌生）</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li><p>正则表达式是一种强大的字符串操作工具。它是一种领域特定语言（DSL），不管是Python还是在大多数现代编程语言中都是作为库存在。</p></li><li><p>它们主要面向两种任务：</p></li></ul><ol><li>   验证字符串是否与模式匹配（例如，字符串具有电子邮件地址的格式）。</li><li>   在字符串中执行替换（例如将所有的大写字母改为小写字母）</li></ol><ul><li>特定于领域的语言是高度专业化的迷你编程语言；</li><li>正则表达式是一个流行的例子，SQL（用于数据库操作）也是一个例子；</li><li>私有领域特定语言通常用于特定的工业目的。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">下面哪个任务不能用正则表达式来实现？</span><br><span class="line">A．检查电子邮件地址是否格式正确</span><br><span class="line">B．更改电子邮件地址URL部分</span><br><span class="line">C．检查电子邮件地址是否真实</span><br><span class="line"></span><br><span class="line">答案：C</span><br></pre></td></tr></table></figure><ul><li>Python中的正则表达式可以使用 re 模块一访问，re模块是标准库的一部分。</li><li>当定义一个正则表达式，可以使用re.match函数用于确定是否匹配字符串的开始部分。如果匹配，则match函数返回表示匹配的对象，如果不匹配则返回None。</li><li>为了避免在处理正则表达式时出现混淆，我们将添加 r 前缀的字符串表达式。该字符串不需要转义任何东西，这样使得正则表达式的使用变得更容易。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern  = <span class="string">r&quot;spam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern,<span class="string">&quot;spamspamspam&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No match&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Match</span><br></pre></td></tr></table></figure><p>上面的示例检查模式spam 是否匹配字符串，如果匹配，则打印Match。</p><p>这里的模式是一个简单的单词，但是有些字符，在正则表达式中使用它们时会有特殊的意义。</p><ul><li>匹配模式的其他函数有 re,search 和re,findall.</li><li>re.search 在字符串中找到匹配；</li><li>re.findall则返回一个包含匹配的列表。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern  = <span class="string">r&quot;spam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern,<span class="string">&quot;eggspamsausagespam&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No match&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.search(pattern,<span class="string">&quot;eggspamsausagespam&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No match&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(re.findall(pattern, <span class="string">&quot;eggspamsausagespam&quot;</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No <span class="keyword">match</span></span><br><span class="line">Match</span><br><span class="line">[<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>在上面的示例中，match函数与模式不匹配，因为它匹配字符串的开始部分，search函数在字符串中找到了一个匹配项。</li><li>函数re.finditer执行与re.findall 相同的操作，但它返回一个迭代器，而不是一个列表。</li></ul><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">re 模块不包含下面哪个函数？</span><br><span class="line">A.Findall</span><br><span class="line">B.Findlist</span><br><span class="line">C.Search</span><br><span class="line">答案：B</span><br></pre></td></tr></table></figure><ul><li>正则表达式的search 函数返回一个对象，包含几个更详细的信息。<br>此方法包括返回字符串匹配的组，返回第一次匹配的开始和结束位置，以及以元组形式返回第一次匹配的开始和结束位置的span 函数。</li></ul><p>实例5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;pam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, <span class="string">&quot;eggspamsausage&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group())</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.start())</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.end())</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.span())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pam</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">(<span class="number">4</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><ul><li>Sub 是正则表达式里非常重要的函数，表达式：<br>re.sub(pattern, repl, string, max&#x3D;0)<br>该方法在字符串替换所有的匹配并把匹配用repl 参数替换，除非使用max 参数来定义最多匹配。方法返回修改后的字符串。</li></ul><p>实例6</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;My name is David.Hi David.&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;David&quot;</span></span><br><span class="line">newstr = re.sub(pattern, <span class="string">&quot;Amy&quot;</span>, <span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(newstr)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My name <span class="keyword">is</span> Amy.Hi Amy.</span><br></pre></td></tr></table></figure><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符使正则表达式比普通字符串方法更强大。它们允许您创建正则表达式来表示诸如一个或多个数字的匹配。</p><ul><li><p>如果要创建与元字符（如$）匹配的正则表达式，元字符的存在就会产生问题，可以通过在元字符前面添加反斜杠来转义元字符。<br>但是这可能导致问题，因为反斜杠在普通Python字符串中也有转义函数，这可能意味着可能将三四个反斜杠排成一行来执行所有转义操作。</p></li><li><p>为避免这种情况，可以使用一个原始字符串，它是一个普通字符串，前面有一个“r”。</p></li><li><p>元字符点 . 用来表示匹配除了换行外的任何字符。</p></li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;gr.y&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;grey&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;gray&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;blue&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span></span><br></pre></td></tr></table></figure><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">四个 . 匹配什么？</span><br><span class="line">答：除了换行外的任何四个字符。</span><br><span class="line"></span><br><span class="line">- ^表示匹配开始， $表示匹配结束。</span><br></pre></td></tr></table></figure><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;^gr.y$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;grey&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;gray&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;stingray&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span></span><br></pre></td></tr></table></figure><p>匹配模式 “^gr.y$” 意味着字符串应该以gr 开头，然后是一个除了换行符以外的任何字符，并以 y 结尾。</p><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>字符类提供了一种只匹配特定字符集中的一个字符的方法。字符类通过方括号把一列字符或一个范围括在了一起。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;[aeiou]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.search(pattern, <span class="string">&quot;grey&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.search(pattern,  <span class="string">&quot;qwertyuiop&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.search(pattern, <span class="string">&quot;rhythm myths&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>匹配模式 [aeiou] 在search 函数中匹配字符串里模式包含的任何一个字符。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[abc][<span class="keyword">def</span>] 匹配什么？</span><br><span class="line">答：abc中的任何字母，然后是<span class="keyword">def</span>中的任何字母。</span><br></pre></td></tr></table></figure><ul><li>字符类可以匹配字符范围。</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>[a – z]</td><td>匹配任何小写字母。</td></tr><tr><td>[A – Z]</td><td>匹配任何大写字母。</td></tr><tr><td>[0 – 9]</td><td>匹配数字。</td></tr><tr><td>[G – P]</td><td>匹配任何大写字母从G到P</td></tr></tbody></table><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">r&quot;[A-Z][A-Z][0-9]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.search(pattern, <span class="string">&quot;LS8&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.search(pattern, <span class="string">&quot;E3&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.search(pattern, <span class="string">&quot;lab&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面示例中的正则模式匹配包含两个大写字母然后跟着一个数字的字符串。</p><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正则模式 [<span class="number">1</span>-<span class="number">5</span>][<span class="number">0</span>-<span class="number">9</span>]匹配什么？</span><br><span class="line"></span><br><span class="line">答：从<span class="number">10</span> 到<span class="number">59</span>的两位数。</span><br></pre></td></tr></table></figure><ul><li>在字符类的开头有^表示匹配非字符类，也就是它与处包含的字符之外的任何字符匹配。</li><li>有些元字符（如$和 . ）在字符类中没有任何意义，元字^同样没有任何意义，除非它是字符类中的第一个字符。</li></ul><p>实例5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;[^A-Z]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.search(pattern, <span class="string">&quot;this is all quiet&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.search(pattern, <span class="string">&quot;AbCdEfG123&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.search(pattern, <span class="string">&quot;THISISALLSHOUTING&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span></span><br></pre></td></tr></table></figure><p>匹配模式[^A-Z] 用于排除大写字符串。注意，^应该位于括号内，表示非此字符类。</p><h2 id="深入元字符"><a href="#深入元字符" class="headerlink" title="深入元字符"></a>深入元字符</h2><h3 id="元字符-1"><a href="#元字符-1" class="headerlink" title="元字符"></a>元字符</h3><ul><li><p>有些比较特殊的元字符是 * ， +， ？，{ 和 }，它们用来指定重复的次数。</p></li><li><p>元字符 * 叫通配符，是匹配范围最广的模式之一，因为它可以匹配零个或多个任意字符（除了换行符： \r 和\n）。并且它总是尝试匹配尽可能多的重复，重复可以是一个字符，一个类或括号中的一组字符。</p></li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;egg(spam)*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;egg&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;eggspamspamegg&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern,<span class="string">&quot;spam&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span>!</span><br></pre></td></tr></table></figure><ul><li>上面示例匹配以egg开头的字符串后面跟随零或更多个spam的字符串。</li><li>它总是尝试匹配尽可能多的重复这种模式叫做贪心模式。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[a^]*匹配什么？</span><br><span class="line"></span><br><span class="line">答：a 或 ^的零次或多次重复。</span><br></pre></td></tr></table></figure><ul><li>元字符 + 与 * 非常相似，只不过它的意思是一个或多个重复，而不是零或多个重复：</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;g+&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;g&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;ggggggggggggg&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern,<span class="string">&quot;abc&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span>!</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>*</td><td>匹配前面表达式的 0次或很多次；</td></tr><tr><td>+</td><td>匹配前面表达式的1 次或很多次。</td></tr><tr><td>？</td><td>匹配前面表达式的零或一个前面的重复</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;ice(-)?cream&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;ice-cream&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;icecream&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern,<span class="string">&quot;sausages&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;ice--ice&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 4&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span>!</span><br></pre></td></tr></table></figure><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请匹配color和colour。</span><br><span class="line"></span><br><span class="line">答：pattern = r”colo(u)?r”</span><br></pre></td></tr></table></figure><h3 id="花括号"><a href="#花括号" class="headerlink" title="花括号"></a>花括号</h3><p>花括号可以用来表示两个数字之间的重复次数。<br>表达式 {x, y }表示匹配出现次数介于 x 和 y 的前面的字符。<br>因此，{0 ， 1}和 ？意思相同。  {1，}和 + 意思相同。<br>如果不写第一个数字，它将默认是0 ，如果不写第二个数字，他被认为是可以匹配很多次。</p><p>实例5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;9&#123;1,3&#125;$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;9&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;999&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern,<span class="string">&quot;9999&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span>!</span><br></pre></td></tr></table></figure><p>9{1，3}$匹配字符串含有1次到3 次的9.</p><p>注意：Python里指定的数字必须小于4294967295且第一个必须小于等于第二个。</p><h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><ul><li>可以通过用括号包围正则表达式的部分来创建组，意味着一个组可以作为元字符（例如 * 或 ？）的参数。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;egg(spam)*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;egg&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;eggspamspamspamegg&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern,<span class="string">&quot;spam&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span>!</span><br></pre></td></tr></table></figure><p>上面例子（spam）表示捕获组。</p><ul><li>可以使用group函数访问捕获组中组的内容。Group（0）或group（）返回全部匹配，group（n）调用n大于0 返回第n 组匹配。Groups（）返回一个包含所有捕获组的元组。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;a(bc)(de)(f(g)h)i&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, <span class="string">&quot;abcdefghijklmnop&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group())</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.groups())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abcdefghi</span><br><span class="line">abcdefghi</span><br><span class="line">bc</span><br><span class="line">de</span><br><span class="line">(<span class="string">&#x27;bc&#x27;</span>, <span class="string">&#x27;de&#x27;</span>, <span class="string">&#x27;fgh&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure><p>捕获组同时可以嵌套，也就是说一个组可以是另一个组的子集。</p><p>注意：子集在最后！！！</p><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对捕获组值<span class="number">1</span>（<span class="number">23</span>）（<span class="number">4</span>（<span class="number">56</span>）<span class="number">78</span>）<span class="number">9</span>（<span class="number">0</span>）的group（<span class="number">3</span>）调用结果是什么？</span><br><span class="line">答：“<span class="number">23</span>” “<span class="number">45678</span>” “<span class="number">0</span>” “<span class="number">56</span>”</span><br></pre></td></tr></table></figure><p>因此group（3）调用的结果为56.</p><ul><li>有一些特殊的捕获组，它们叫非捕获组和命名捕获组。</li><li>命名捕获组的格式是（？P<name>…），其中name是组的名称， … 是要匹配的表达式。它们的行为与正常组完全相同，除了可以通过索引访问还可以通过group（name）方式访问它们。</name></li><li>非捕获组的格式是（？：…）。非捕获组只匹配结果，但不捕获结果，也不会分配组号，当然也不能在表达式和程序中做进一步处理。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;(?P&lt;first&gt;abc)(?:def)(ghi)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, <span class="string">&quot;abcdefghi&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="string">&quot;first&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.groups())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>)</span><br></pre></td></tr></table></figure><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（a）（b（？：c）（d）（？:e））捕获值的<span class="built_in">len</span>（<span class="keyword">match</span>.groups()）是多少？</span><br><span class="line"></span><br><span class="line">“a”  “bd” “d”</span><br><span class="line">答：<span class="number">3</span>个</span><br></pre></td></tr></table></figure><h3 id="元字符-2"><a href="#元字符-2" class="headerlink" title="元字符"></a>元字符</h3><ul><li>或匹配的元字符 | ，表示red | blue 匹配red或者blue。</li></ul><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;gr(a|e)y&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;gray&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, <span class="string">&quot;grey&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(pattern,<span class="string">&quot;griy&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span>!</span><br></pre></td></tr></table></figure><p>实例5（不理解）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">哪个正则表达式和其他两个不一样？</span><br><span class="line">A．[<span class="number">1</span>- <span class="number">6</span>]</span><br><span class="line">B．(<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>)</span><br><span class="line">C．[<span class="number">12345</span>]</span><br><span class="line"></span><br><span class="line">答案：A</span><br></pre></td></tr></table></figure><h2 id="特殊匹配字符（不理解）"><a href="#特殊匹配字符（不理解）" class="headerlink" title="特殊匹配字符（不理解）"></a>特殊匹配字符（不理解）</h2><ul><li>在正则表达式中可以使用各种的捕获组序列。它们被写成反斜杠，后面跟着另一个数字字符。</li><li>特殊序列式一个反斜杠和一个介于1 到99 之间的数字，比如：\1.数字自发表示捕获组的序列，也就是说我们可以在正则表达式里引用先前的捕获组。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;(.+) \1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, <span class="string">&quot;word word&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, <span class="string">&quot;?! ?!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, <span class="string">&quot;abc cde&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span></span><br></pre></td></tr></table></figure><p>注意：<br>（.+） \1不等同于（.+）(.+),因为\1引用第一个组的表达式，即匹配表达式本身，而不是正则匹配模式。<br>注意：括号和反斜杠之间还有空格，如果没哟空格编译结果不一样！！！！！！！！</p><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（abc|xyz）\<span class="number">1</span>匹配哪一个？</span><br><span class="line">答：abc或者xyz后面跟着同样的字符串。</span><br></pre></td></tr></table></figure><ul><li>正则中还要一些特殊的匹配模式</li></ul><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>\d,</td><td>匹配数字</td><td>在ascll模式中正则里等同 [0-9]</td></tr><tr><td>\s，</td><td>匹配空白</td><td>在ascll模式中正则里等同[\t\n\r\f\v]</td></tr><tr><td>\w，</td><td>匹配单词字符。</td><td>在ascll模式中正则里等同[a-zA-Z0-9].</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><ul><li>如果把这几个字母编程大写\D, \S和\W,那么意味着匹配模式相反。例如：\D匹配非数字。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;(\D+\d)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, <span class="string">&quot;Hi 999!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, <span class="string">&quot;1, 23, 456!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, <span class="string">&quot;! $?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br></pre></td></tr></table></figure><p>（\D+\d）意味着匹配一个或者多个非数字后面跟随一个数字。</p><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">哪个正则模式不会匹配<span class="number">123</span>！<span class="number">456</span>！</span><br><span class="line">A．[<span class="number">11</span>-<span class="number">6</span>！]</span><br><span class="line">B．(\D+\s?)+</span><br><span class="line">C．(\d*\W)+</span><br><span class="line">答案：大写D表示非数字。</span><br></pre></td></tr></table></figure><ul><li>还有一些特殊的匹配表达式\A   \Z   \b。</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>\A</td><td>仅匹配字符串的开始，大多数情况下，它的作用等同于在模式中使用^.</td></tr><tr><td>\Z</td><td>仅匹配字符串的结束，大多数情况下相等于$。</td></tr><tr><td>\b</td><td>匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。相当于\w 和\W 之间有一个空字符串。</td></tr><tr><td>\B</td><td>匹配一个非单词边界。它匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。</td></tr><tr><td></td><td></td></tr></tbody></table><p>实例5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;\b(cat)\b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, <span class="string">&quot;The cat sat!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, <span class="string">&quot;we s&gt;cat&lt;tered?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, <span class="string">&quot;We scat tered.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match 3&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match <span class="number">1</span></span><br><span class="line">Match <span class="number">2</span></span><br></pre></td></tr></table></figure><p>注意：<br>一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度为0. “\b(cat)\b” 匹配的结果是“ cat”。</p><p>实例6</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用re.search 时下面哪个匹配 ‘SPAM！’.</span><br><span class="line">A.\AS...\b\Z</span><br><span class="line">B.SP\AM!\Z</span><br><span class="line">C.\ASPAM\Z</span><br><span class="line"></span><br><span class="line">答案：A</span><br><span class="line">B格式错误吧！\A 只能在开头</span><br></pre></td></tr></table></figure><h2 id="邮件地址提取"><a href="#邮件地址提取" class="headerlink" title="邮件地址提取"></a>邮件地址提取</h2><p>为演示正则表达式的示例用法，创建了一个从字符串中提取电子邮箱地址的程序。假设有一个包含电子邮箱地址的字符串：<br><code>Str= “Please contact info@sololean.com for assistance”</code></p><p>我们希望提取出类似 <a href="mailto:&#x69;&#110;&#x66;&#111;&#x40;&#x73;&#111;&#x6c;&#x6f;&#x6c;&#101;&#x61;&#114;&#x6e;&#46;&#99;&#111;&#109;">&#x69;&#110;&#x66;&#111;&#x40;&#x73;&#111;&#x6c;&#x6f;&#x6c;&#101;&#x61;&#114;&#x6e;&#46;&#99;&#111;&#109;</a>的字符串。一个典型的电子邮件地址由一个词组成，可以包括点或破折号。接下来是@符号和域名（名称，一个点和域名后缀）。下面是我们用来构建正则的基础框架。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&quot;([\w\.-]+)@([\w\.-]+)(\.[\w\.]+)&quot;</span></span><br></pre></td></tr></table></figure><ul><li>[\w.-]匹配一个或多个字字符，点或破折号。上面的正则表达式表示字符串应该包含一个单词（包含点和破折号），后面跟着@符号，接着是另一个类似的单词，然后是一个点和另一个单词。</li><li>我们的正则包含三个组：</li></ul><ol><li>   电子邮箱的第一部分用户名</li><li>   无后缀的域名</li><li>   域名的后缀</li></ol><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下面哪个必须用正则表达式而不是字符串的方法来完成？</span><br><span class="line">A．切分字符串</span><br><span class="line">B．检查字符串里面是否包含日期</span><br><span class="line">C．检查某个字符是否包含在字符串里面。</span><br><span class="line">答案：B</span><br></pre></td></tr></table></figure><p>实例2邮件地址提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&quot;([\w\.-]+)@([\w\.-]+)(\.[\w\.]+)&quot;</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Please contact info@sololearn.com for assistance&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, <span class="built_in">str</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info@sololearn.com</span><br></pre></td></tr></table></figure><ul><li>如果字符串包含多个电子邮件地址，可以使用re.findall方法而不是rre.search来提取所有电子邮件地址。</li><li>本例中的正则只是为了演示目的，现实情况下需要更复杂的正则表达式才能完全验证电子邮件地址。</li></ul><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在例子中为什么要用斜杠\来处理逗号.？</span><br><span class="line">答：把它当作一个字符。</span><br></pre></td></tr></table></figure><p>实例4 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正则表达式（ab）（c（d（e）f））（g）有多少个组？</span><br><span class="line">答：<span class="number">5</span>个</span><br><span class="line">有几个括号就有几个组。</span><br></pre></td></tr></table></figure><p>实例5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">哪个正则能够匹配 email@domain.com ?</span><br><span class="line">A.[<span class="number">0</span>-<span class="number">9</span>]@domain\.com</span><br><span class="line">B.\w+@domain.com</span><br><span class="line">C.Email\@(domain\w)+</span><br><span class="line"></span><br><span class="line">答案：B</span><br></pre></td></tr></table></figure><p>实例6</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[01]+<span class="number">0</span>$匹配哪个字符串？</span><br><span class="line">A.<span class="number">0</span>101</span><br><span class="line">B.011101</span><br><span class="line">C.<span class="number">10101111001010</span></span><br><span class="line">答案：C</span><br><span class="line">以<span class="number">0</span>结束！</span><br></pre></td></tr></table></figure><p>实例7（不理解）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下面哪个选项能够匹配（<span class="number">4</span>&#123;<span class="number">5</span>,<span class="number">6</span>&#125;）\<span class="number">1</span> ?</span><br><span class="line">A.<span class="number">456</span></span><br><span class="line">B.<span class="number">5</span>或者<span class="number">6</span>个<span class="number">4</span></span><br><span class="line">C.<span class="number">10</span>或者<span class="number">12</span>个<span class="number">4</span></span><br><span class="line">答案：C</span><br></pre></td></tr></table></figure><h1 id="深入了解Python"><a href="#深入了解Python" class="headerlink" title="深入了解Python"></a>深入了解Python</h1><h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h2><p>让程序运行能够正确只是成为一个优秀的Python程序员的一部分。编写抑郁理解的清晰代码同样也很重要。<br>想要学好一门编程语言，就需要接受这门语言的哲学。那么如果你想精通Python，就需要践行Python背后的设计哲学，</p><ul><li><p>访问Python之禅的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">he Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than <span class="built_in">complex</span>.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">&#x27;t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you&#x27;</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">&#x27;s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let&#x27;</span>s do more of those!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>翻译一下：</p><blockquote></blockquote><p>  Python之禅，by Tim Peters<br>  优美胜于丑陋，明确胜于隐晦。<br>  简单胜于复杂，复杂胜于凌乱。<br>  扁平胜于嵌套，稀疏胜于紧凑。<br>  可读性至关重要<br>  即便特例，也需服从以上规则。<br>  除非刻意追求，错误不应跳过。<br>  面对歧义条件，拒绝尝试猜测。<br>  解决问题的最优方法应该有且只有一个。<br>  尽管这一方法并非显而易见。<br>  动手胜于空想，空想胜于不想。<br>  难以解释的实现方案，不是好方案。<br>  易于解释的实现方案，才是好方案。<br>  命名空间是个绝妙的理念，多多益善！</p></li><li><p>有些行需要单独解释一下。</p></li><li><p>显式比隐式更好：最好准确地说明代码正在做什么。这就是为什么像整数和数字字符串相加需要显式转换，而不是像在其他语言中那样进行隐式转化。</p></li><li><p>平面比嵌套要好：应该避免重嵌套结构（列表中套列表，列表中套列表）。</p></li><li><p>例外不应该悄悄传递：通常，当例外放生是，应该输出某种消息，而不是直接忽略它。</p></li><li><p>“解决问题的最优方法应该有且只有一个，尽管这一方法并非显而易见。”这句话引用并反驳了Perl语言的哲学，即应该有一种以上的方法来做到这一点。</p></li></ul><p>编程世界也是帮派林立！！！</p><p>哈哈哈！我要立于万林之中！！！！！！</p><h2 id="Python编程规范"><a href="#Python编程规范" class="headerlink" title="Python编程规范"></a>Python编程规范</h2><p>Python编程规范，英文PythonEnhancement Proposals（PEP）。是由经验丰富的Python开发人员提出的对语言的规范改进建议。PEP8是最受欢迎的关于编写可读代码的指南，它包含了一些关于变量名称的指南，下面是一些准则：</p><blockquote></blockquote><pre><code>1)模块应该有见解和全小写的名称。2)类名应该首字母大写CapWords这样的方式。3)大多数变量和函数名应该是小写加下划线lowercase_with_wunderscores这样的方式。4)常量（变量值不会被改动）应该是大写加下划线CAPS_WITH_WUNDERSCORES这样的方式。5)字符串不要以空格收尾。6)类的属性若与关键字名字冲突，加一个后缀下划线，尽量不要使用缩略等其他方式。</code></pre><p>PEP8还建议在运算符周围和逗号后面使用空格，以提高可读性。</p><ul><li>但是不应该过度使用空白。例如，避免在任何类型的括号内直接留出任何空格。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">哪种符合PEP8推荐作为类的名称？</span><br><span class="line">A.MyClassName</span><br><span class="line">B.my_class_name</span><br><span class="line">C.My_Class_Name</span><br><span class="line">答案：A</span><br></pre></td></tr></table></figure><h3 id="PEP8"><a href="#PEP8" class="headerlink" title="PEP8"></a>PEP8</h3><p>PEP8还推荐如下：</p><blockquote></blockquote><pre><code>每行应不超过80个字符；应该避免“from module import *”。每行只应该有一条语句。确保对模块，函数，方法和行内注释使用正确的风格。</code></pre><p>它还建议使用空格，而不是制表符来缩进，更不能混合使用制表符和空格。然而在某种程度上，这是个人喜好的问题，如果使用空格，推荐每次值使用4个空格的缩进，选择其中一种方式更重要，并坚持下去。</p><p>PEP中最重要的建议是，在你认为有意义的时候忽略规范。如果PEP建议会导致代码的可读性降低，与周围代码不一致或者不向后兼容，则不要再遵循PEP建议，总的来说，遵循PEP8将大大提高代码的质量。</p><ul><li>其他一些PEP包含代码样式规范：</li><li>PEP20：Python之禅</li><li>PEP257：代码中使用的Docstring特性。</li></ul><h2 id="深入函数参数"><a href="#深入函数参数" class="headerlink" title="深入函数参数"></a>深入函数参数</h2><h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li>Python允许具有可变长参数的函数。使用*args作为函数参数， 可以将任意数量的参数传递给该函数。然后，参数可以作为函数体中的元组访问。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">nameed_arg, *args</span>):</span><br><span class="line">    <span class="built_in">print</span>(nameed_arg)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">function(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li>参数*args 必须位于函数的命名参数之后，其没有key值，可以使用任何名称替换args。</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何在函数里访问 *args？</span><br><span class="line">答：把args当元组。</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>函数的命名参数可以通过给出默认值而成为可选参数，这些参数必须在不需要默认值命名参数的后面。</p><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">x,y, food=<span class="string">&quot;spam&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(food)</span><br><span class="line"></span><br><span class="line">function(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">function(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;egg&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spam</span><br><span class="line">egg</span><br></pre></td></tr></table></figure><ul><li>如果这个参数调用时给出，那么忽略默认值，否则使用默认值。</li></ul><h3 id="函数参数-2"><a href="#函数参数-2" class="headerlink" title="函数参数"></a>函数参数</h3><p>**kwargs（关键字参数）允许处理预先定义的命名参数。关键字参数返回一个字典，其中键是参数名，值是参数值。</p><p>实例4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">x, y=<span class="number">7</span>, *args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="built_in">print</span>(y)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">my_func(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, a=<span class="number">7</span>, b=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>a 和b是传递给函数调用参数的名称。</li><li>传递给*<em>kwargs 的参数不包含传递给</em>args的参数。</li><li>Kwargs是词典类型</li></ul><h2 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h2><p>元组拆包允许你将可迭代中（大多是元组）的每个项分配给一个变量。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">a, b, c = numbers</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><p>这也可用于交换变量，方法是 a, b &#x3D; b, a 。由于b，a在右边隐式形成元组（b，a），然后使用拆包技术。</p></li><li><p>以星号（*）作为前缀的变量接受其他白娘遗留的所有可迭代值。</p></li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a, b, *c, d = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><ul><li>条件表达式提供if 语句的功能，同时代码简洁。尽量避免过度使用，因为它很容易降低可读性，但是在分配变量时会经常用到。条件表达式被称为三元运算符。</li></ul><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">7</span></span><br><span class="line">b = <span class="number">1</span> <span class="keyword">if</span> a&gt;=<span class="number">5</span> <span class="keyword">else</span> <span class="number">42</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>三元操作符检查条件判断并返回响应的值。如果条件为真，b的值为1.如果a小于5，那么b的值为42.</li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">status = <span class="number">1</span></span><br><span class="line">msg = <span class="string">&quot;Logout&quot;</span> <span class="keyword">if</span> status ==<span class="number">1</span> <span class="keyword">else</span> <span class="string">&quot;Login&quot;</span></span><br><span class="line"><span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logout</span><br></pre></td></tr></table></figure><h2 id="深入else语句"><a href="#深入else语句" class="headerlink" title="深入else语句"></a>深入else语句</h2><h3 id="else语句"><a href="#else语句" class="headerlink" title="else语句"></a>else语句</h3><p>else语句通常与if 语句一起使用，但它也可以和for 或while 循环一起使用，这给我们带来了更多惊喜。<br>对于for 或 while 循环，如果循环正常结束（当终端语句不导致循环退出）时，else内的代码块被调用。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i ==<span class="number">999</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unbroken 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unbroken 2&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unbroken <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><p>第一个for循环执行正常，导致打印出Unbroken 1.第二个diamante由于调用了break那么else语句没有被调用。</p></li><li><p>Else语句同样可以用在try&#x2F;except 语句里。在这种情况下，只有在try语句没有例外时，才执行else 的代码。</p></li></ul><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>实例3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span> + <span class="string">&quot;1&quot;</span> == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="main"><a href="#main" class="headerlink" title="_ main _"></a>_ <em>main</em> _</h2><p>大多数Python代码要么是要导入的模块，要么是执行某些任务的脚本。但是，有时需要使一个文件既可以作为模块导入，又可以作为脚本运行。</p><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a module function&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a script&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This <span class="keyword">is</span> a script</span><br></pre></td></tr></table></figure><ul><li>当Python解释器读取源文件时，它会执行它在文件中找到的所有代码。在执行代码之前，它定义了一些特殊的变量。</li><li>例如，如果Python解释器将该模块（源文件）作为主程序运行，它将一个特殊的__name__变量设置为字符串值“__main__”如果该文件是从另一个模块导入的，__name__将设置为该模块的名称。</li></ul><p>实例2（不理解）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果作为模块导入哪个变量将访问不到？</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = x</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    z = <span class="number">3</span></span><br><span class="line">答：Z</span><br></pre></td></tr></table></figure><ul><li><p>如果我们把上一个例子的代码使用一个文件名为sololearn.py 保存，使用名字sololearn可以导入到另一个脚本作为一个模块，</p></li><li><p>Sololearn.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a module function&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a script&quot;</span>)</span><br><span class="line"></span><br><span class="line">- Some_script.py</span><br><span class="line"><span class="keyword">import</span> scratch</span><br><span class="line">scratch.function()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This <span class="keyword">is</span> a module function</span><br></pre></td></tr></table></figure><p>我们创建了一个模块sololearn 并且通过另外的脚本来调用。</p></li></ul><p>实例3（不理解）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过作为模块导入的方式输出Welcome否则输出Hi。</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="常用第三方模块"><a href="#常用第三方模块" class="headerlink" title="常用第三方模块"></a>常用第三方模块</h2><ul><li><p>除了内建的模块外，Python还有大量的第三方模块。<br>Django 是Python最常用的Web框架，它支持Instagram 和Disqus等网站运行。它有许多非常有用的特性，并且它缺少的特性都可由它的扩展包来满足。CherryPy 和 Flask同样也是非常流行的Web框架。<br>如果要从网上爬取数据BeautifulSoup模块将帮你省很多力量，这比用正则表达式构建自己的数据提取规则要好很多。</p></li><li><p>虽然Python提供了以变成方式访问网站（如urllib）的模块，但它们的使用非常麻烦。使用第三方哭request会使HTTP请求变得更加容易。</p></li><li><p>有许多第三方模块可以帮助Python实现科学和数学计算。Matplotlib模块允许你使用Python来创建2D图形。模块NumPy允许使用比原生Python解决方案快得多的多维数组，同时它还包含执行数学操作的函数，例如对数组的矩阵转换。模块SCIPy包含对NumPy功能的许多扩展。</p></li><li><p>Python同样可以用来做游戏开发。它通常被用来作为使用其他语言编写游戏的脚本语言。但是也可以用来自己制作游戏。</p></li><li><p>Panda3D 模块帮助你建立3D游戏，pygame帮助你建立2D游戏。</p></li></ul><h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><ul><li><p>在Python中，打包一词是指将您编写的模块以标准格式编写，以便其他程序员能够轻松地安装和使用它们。这涉及到模块、setuptools和distutils的使用。</p></li><li><p>打包的第一步是正确组织文件。将要放入库中的所有文件放在同一个父目录中。该目录还应该包含一个名为__init__.py的文件，该文件可以是空的，但必须存在于目录中。这个目录放在另一个包含自述文件和许可文件的目录下，同时还有一个非常重要的文件setup.py目录结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SoloLearn/</span><br><span class="line">    LICENSE.txt</span><br><span class="line">    README.TXT</span><br><span class="line">    setup.py</span><br><span class="line">    sololearn/</span><br><span class="line">        __init__.py</span><br><span class="line">        sololearn.py</span><br><span class="line">        sololearn2.py</span><br></pre></td></tr></table></figure><p>可以根据需要在目录中放置很多的Python脚本文件。</p></li><li><p><strong>init</strong>.py是打包需要的文件</p></li><li><p>下一步是在setup.py文件里写打包命令，里面包含了软件包所需的信息，以便将其上传到PyPI并通过pip安装。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;SoloLearn&#x27;</span>,</span><br><span class="line">    version=<span class="string">&#x27;0.1dev&#x27;</span>,</span><br><span class="line">    packages =[<span class="string">&#x27;sololearn&#x27;</span>],</span><br><span class="line">    license=<span class="string">&#x27;MT&#x27;</span>,</span><br><span class="line">    log_description= <span class="built_in">open</span>(<span class="string">&#x27;README.txt&#x27;</span>).read(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>创建setup.py文件后，可将其上传到PyPI上，或使用命令行构建二进制的发行版（可执行安装程序）。</p></li><li><p>要构建一个发行版，请使用命令行进入到包含setup.py的目录，并运行命令python setup.py sdist创建源码分发包，Windows下可运行python setup.py bdist_wininst来构建二进制的发行版。</p></li><li><p>使用python setup.py register 注册账号，使用python setup.py sdist upload上传大家可下载的发行版。</p></li></ul><h3 id="Packaging"><a href="#Packaging" class="headerlink" title="Packaging"></a>Packaging</h3><ul><li>前面介绍了供其他Python程序员使用的模块打包方法。如果你的用户不是程序员，那么他的计算机大多数没有安装Python。因此，需要将脚本打包为相关平台（如Windows）的可执行文件。</li><li>在Windows平台上，有许多工具可用于将python脚本转换为可执行文件。</li><li>Py2exe可以用于将python脚本和它所需的库打包到单个可执行文件中，也可以用Pyinstaller 或cx_Freeze.</li><li>对于Linux或Mac用户来说这是不必要的，因为大多数用户都安装了Python。</li></ul><h2 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h2><p>实例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">10</span> / i ==<span class="number">2.0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/python/">python</category>
      
      
      <comments>http://example.com/2023/12/06/python%E6%95%99%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LVGL笔记教程</title>
      <link>http://example.com/2023/12/03/LVGL%E7%AC%94%E8%AE%B0%E6%95%99%E7%A8%8B/</link>
      <guid>http://example.com/2023/12/03/LVGL%E7%AC%94%E8%AE%B0%E6%95%99%E7%A8%8B/</guid>
      <pubDate>Sun, 03 Dec 2023 12:49:27 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;LVGL移植要求（熟悉）&quot;&gt;&lt;a href=&quot;#LVGL移植要求（熟悉）&quot; class=&quot;headerlink&quot; title=&quot;LVGL移植要求（熟悉）&quot;&gt;&lt;/a&gt;LVGL移植要求（熟悉）&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LVGL移植要求（熟悉）"><a href="#LVGL移植要求（熟悉）" class="headerlink" title="LVGL移植要求（熟悉）"></a>LVGL移植要求（熟悉）</h1><span id="more"></span><p>此要求仅针对V8版本：</p><blockquote><ul><li>16、32或64位微控制器或者处理器</li><li>主控频率：&gt; 16Mhz</li><li>Flash&#x2F;ROM: &gt;64kb,建议180kb以上</li><li>RAM: &gt;8kb,建议24kb以上</li><li>图形缓冲区： &gt;水平分辨率像素，建议大雨1&#x2F;10屏幕总像素</li><li>C99或更新的版本的编译器。</li><li></li></ul></blockquote><p>优化LVGL运行效果的方法</p><blockquote><ul><li>提高芯片主频</li><li>增大SRAM容量、提高读写速度</li><li>增大图形缓冲区、使用双缓冲</li><li>减小需要刷新的总像素</li><li>提高图像数据的传输速度 DMA2D</li><li>关键点： 缩短图像刷新所需要的时间</li></ul></blockquote><p>LVGL资料获取（了解）</p><blockquote><ul><li>途径1:LVGL官网：<a href="https://lvgl.io/">https://lvgl.io</a></li><li>途径2:LGVL的GitHub仓库：<a href="https://github.com/lvgl/lvgl">https://github.com/lvgl/lvgl</a></li><li>途径3: 正点原子STM32 开发板里面</li></ul></blockquote><p>学习LVGL之前建议掌握的知识：</p><table><thead><tr><th>知识点</th><th>要求</th></tr></thead><tbody><tr><td>定时器</td><td>初始化、中断</td></tr><tr><td>屏幕</td><td>显示、触摸、DMA2D</td></tr><tr><td>SRAM、内存管理</td><td>初始化、内存分配</td></tr><tr><td>文件系统、SD卡</td><td>初始化、读写</td></tr><tr><td>系统（FREERTOS）</td><td>移植、创建任务、获取心跳</td></tr><tr><td>C语言</td><td>指针、结构体</td></tr></tbody></table>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2023/12/03/LVGL%E7%AC%94%E8%AE%B0%E6%95%99%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>sort |unique-排序</title>
      <link>http://example.com/2023/10/27/sort-unique%E7%AC%94%E8%AE%B0/</link>
      <guid>http://example.com/2023/10/27/sort-unique%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Fri, 27 Oct 2023 06:39:22 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Linux-sort-排序命令&quot;&gt;&lt;a href=&quot;#Linux-sort-排序命令&quot; class=&quot;headerlink&quot; title=&quot;Linux sort 排序命令&quot;&gt;&lt;/a&gt;Linux sort 排序命令&lt;/h1&gt;&lt;p&gt;Linux sort 命令用于将文本文件内容加以排序。&lt;br&gt;sort 可针对文本文件的内容，以行为单位来排序。       &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Linux-sort-排序命令"><a href="#Linux-sort-排序命令" class="headerlink" title="Linux sort 排序命令"></a>Linux sort 排序命令</h1><p>Linux sort 命令用于将文本文件内容加以排序。<br>sort 可针对文本文件的内容，以行为单位来排序。       </p><span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--<span class="built_in">help</span>][--verison][文件][-k field1[,field2]]  </span><br></pre></td></tr></table></figure><h2 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>忽略每行前面开始出的空格字符。</td></tr><tr><td>-c</td><td>检查文件是否已经按照顺序排序。</td></tr><tr><td>-d</td><td>排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</td></tr><tr><td>-f</td><td>排序时，将小写字母视为大写字母。</td></tr><tr><td>-i</td><td>排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</td></tr><tr><td>-m</td><td>将几个排序好的文件进行合并。</td></tr><tr><td>-M</td><td>将前面3个字母依照月份的缩写进行排序。</td></tr><tr><td>-n</td><td>依照数值的大小排序。</td></tr><tr><td>-u</td><td>意味着是唯一的(unique)，输出的结果是去完重了的。｜</td></tr><tr><td>-o</td><td>&lt;输出文件&gt; 将排序后的结果存入指定的文件。｜</td></tr><tr><td>-r</td><td>以相反的顺序来排序。｜</td></tr><tr><td>-t&lt;分隔字符&gt;</td><td>指定排序时所用的栏位分隔字符。｜</td></tr><tr><td>+&lt;起始栏位&gt;-&lt;结束栏位&gt;</td><td>以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。｜</td></tr><tr><td>–help</td><td>显示帮助。｜</td></tr><tr><td>–version</td><td>显示版本信息。｜</td></tr><tr><td>[-k field1[,field2]]</td><td>按指定的列进行排序。｜</td></tr></tbody></table><p>常用的参数有：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-u</td><td>排序去重</td></tr><tr><td>-r</td><td>反向排序</td></tr><tr><td>-t</td><td>指定分隔符</td></tr><tr><td>-k</td><td>指定列排序</td></tr></tbody></table><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在使用 sort 命令以默认的式对文件的行进行排序，使用的命令如下：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> testfile </span><br></pre></td></tr></table></figure><p>sort 命令将以默认的方式将文本文件的第一列以 ASCII 码的次序排列，并将结果输出到标准输出。<br>使用 cat 命令显示 testfile 文件可知其原有的排序如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> testfile      <span class="comment"># testfile文件原有排序  </span></span><br><span class="line"><span class="built_in">test</span> 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85 </span><br></pre></td></tr></table></figure><p>使用 sort 命令重排后的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sort</span> testfile <span class="comment"># 重排结果  </span></span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85  </span><br><span class="line"><span class="built_in">test</span> 30 </span><br></pre></td></tr></table></figure><p>使用 -k 参数设置对第二列的值进行重排，结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sort</span> testfile -k 2</span><br><span class="line"><span class="built_in">test</span> 30  </span><br><span class="line">Linux 85 </span><br><span class="line">Hello 95  </span><br></pre></td></tr></table></figure><p>使用t参数以,为分隔符，参数k指定按照第二列的数据进行排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> -t <span class="string">&#x27;,&#x27;</span> -k 2 testfile2</span><br></pre></td></tr></table></figure><h1 id="Linux-uniq-排序命令"><a href="#Linux-uniq-排序命令" class="headerlink" title="Linux uniq 排序命令"></a>Linux uniq 排序命令</h1><p>可检查文本文件中重复出现的行列</p><p>##语法： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uniq</span> [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--<span class="built_in">help</span>][--version][输入文件][输出文件] </span><br></pre></td></tr></table></figure><p>##参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-c或–count</td><td>在每列旁边显示该行重复出现的次数</td></tr><tr><td>-d或–repeated</td><td>仅显示重复出现的行列</td></tr><tr><td>-f&lt;栏位&gt;或–skip-fields&#x3D;&lt;栏位&gt;</td><td>忽略比较指定的栏位</td></tr><tr><td>-s&lt;字符位置&gt;或–skip-chars&#x3D;&lt;字符位置&gt;</td><td>忽略比较指定的字符</td></tr><tr><td>-u或–unique</td><td>仅显示出一次的行列</td></tr><tr><td>-w&lt;字符位置&gt;或–check-chars&#x3D;&lt;字符位置&gt;</td><td>指定要比较的字符</td></tr><tr><td>–help</td><td>显示帮助</td></tr><tr><td>–version</td><td>显示版本信息</td></tr><tr><td>[输入文件]</td><td>指定已排序好的文本文件。如果不指定此项，则从标准读取数据</td></tr><tr><td>[输出文件]</td><td>指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）</td></tr></tbody></table><h1 id="补充：sort与unique的区别"><a href="#补充：sort与unique的区别" class="headerlink" title="补充：sort与unique的区别"></a>补充：sort与unique的区别</h1><pre><code>两者都可去重，但uniq去除的是连续出现的相同记录，sort -u 则可以去除连续或者不连续的相同记录.</code></pre><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@mysql ~]<span class="comment"># cat test.txt </span></span><br><span class="line">a</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">ff</span><br><span class="line">12</span><br><span class="line">fff</span><br><span class="line">a</span><br><span class="line">ff</span><br><span class="line">[root@mysql ~]<span class="comment"># sort -u test.txt </span></span><br><span class="line">12</span><br><span class="line">123</span><br><span class="line">a</span><br><span class="line">ff</span><br><span class="line">fff</span><br><span class="line">[root@mysql ~]<span class="comment"># uniq test.txt </span></span><br><span class="line">a</span><br><span class="line">123</span><br><span class="line">a</span><br><span class="line">ff</span><br><span class="line">12</span><br><span class="line">fff</span><br><span class="line">a</span><br><span class="line">ff</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果想把文本里所有的重复项去掉，可用 <code>sort -u</code></p><p>如果想统计重复项的次数并排序，需结合<code>uniq</code>，先排序再去重再排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@mysql ~]<span class="comment"># sort test.txt |uniq -c| sort -r</span></span><br><span class="line">      4 a</span><br><span class="line">      2 ff</span><br><span class="line">      2 123</span><br><span class="line">      1 fff</span><br><span class="line">      1 12</span><br></pre></td></tr></table></figure><p>实际中可用来统计连接数最多的ip：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -na|grep ESTABLISHED|awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span>|awk -F: <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>|<span class="built_in">sort</span>|<span class="built_in">uniq</span> -c|<span class="built_in">sort</span> -n</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/linux/">linux</category>
      
      
      <category domain="http://example.com/tags/sort-linux-%E6%8E%92%E5%BA%8F/">sort linux 排序</category>
      
      
      <comments>http://example.com/2023/10/27/sort-unique%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C语言笔记</title>
      <link>http://example.com/2023/10/24/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</link>
      <guid>http://example.com/2023/10/24/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 24 Oct 2023 02:49:38 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Linux系统调用之fork，getpid，getppid函数&quot;&gt;&lt;a href=&quot;#Linux系统调用之fork，getpid，getppid函数&quot; class=&quot;headerlink&quot; title=&quot;Linux系统调用之fork，getpid，getppid函数&quot;&gt;&lt;/a&gt;Linux系统调用之fork，getpid，getppid函数&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Linux系统调用之fork，getpid，getppid函数"><a href="#Linux系统调用之fork，getpid，getppid函数" class="headerlink" title="Linux系统调用之fork，getpid，getppid函数"></a>Linux系统调用之fork，getpid，getppid函数</h1><span id="more"></span><p>如果，想要深入的学习Linux系统调用中的fork，getpid，getppid函数，还是需要去自己阅读Linux系统中的帮助文档。<br>具体输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 fork/getpid/getppid</span><br></pre></td></tr></table></figure><p>即可查阅到完整的资料信息。</p><h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p>fork() 函数是 UNIX&#x2F;Linux 系统中的一个系统调用 (system call)，它会创建一个新的进程，称为子进程，该子进程是原始进程的副本。</p><p>调用 fork() 后，两个进程都将从当前指令序列的下一条指令开始运行，但子进程完全复制了父进程的内存空间、打开文件等状态信息（子进程获得了对共享内存区域的独立控制权，即父进程和子进程之间不会相互干扰）。</p><p>我们可以通过返回值来区分是在哪个进程中。具体地讲，在父进程中，它返回子进程的 Process ID (PID) ，而在子进程中，它返回0.</p><p>fork()的函数原型是长这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure><p>在使用这个函数之前，我们需要往C&#x2F;C++文件中导入这些头文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br></pre></td></tr></table></figure><p>下面用一个代码例子来演示一下fork函数的作用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    int num = 10;</span><br><span class="line"></span><br><span class="line">    // 创建子进程</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">    // 判断是父进程还是子进程</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; 0) &#123;</span><br><span class="line">        // <span class="built_in">printf</span>(<span class="string">&quot;pid : %d\n&quot;</span>, pid);</span><br><span class="line">        // 如果大于0，返回的是创建的子进程的进程号，当前是父进程</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num : %d\n&quot;</span>, num);</span><br><span class="line">        num += 10;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num += 10 : %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == 0) &#123;</span><br><span class="line">        // 当前是子进程</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num : %d\n&quot;</span>, num);</span><br><span class="line">        num += 100;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num += 100 : %d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // <span class="keyword">for</span>循环</span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());</span><br><span class="line">        <span class="built_in">sleep</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nowcoder@nowcoder:~/Linux/lession18$ <span class="built_in">cd</span> <span class="string">&quot;/home/nowcoder/Linux/lession18/&quot;</span> &amp;&amp; gcc fork.c -o fork &amp;&amp; <span class="string">&quot;/home/nowcoder/Linux/lession18/&quot;</span>fork</span><br><span class="line">i am parent process, pid : 29230, ppid : 28564</span><br><span class="line">parent num : 10</span><br><span class="line">parent num += 10 : 20</span><br><span class="line">i : 0 , pid : 29230</span><br><span class="line">i am child process, pid : 29231, ppid : 29230</span><br><span class="line">child num : 10</span><br><span class="line">child num += 100 : 110</span><br><span class="line">i : 0 , pid : 29231</span><br><span class="line">i : 1 , pid : 29230</span><br><span class="line">i : 1 , pid : 29231</span><br><span class="line">i : 2 , pid : 29230</span><br><span class="line">i : 2 , pid : 29231</span><br></pre></td></tr></table></figure><p>在这个例子中，代表父进程的 if (pid &gt; 0) 分支和代表子进程的 if (pid &#x3D;&#x3D; 0) 分支会同时执行。</p><p>简单来说，fork() 的作用就是在程序中生成一个新的进程，这个新的进程和原有进程基本一致，除了 fork() 的返回值。这两个进程几乎是同时运行的。一般情况下，父进程将 fork() 的返回值保存，并通过这个唯一的返回值标识子进程。子进程也可以通过 getppid 获得其父进程的 PID.</p><p>实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</p><p>大概就向图中一样：</p><p><img src="image.png" alt="Alt text"></p><p>注意：fork之后父子进程共享文件，<br>fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</p><h2 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a>getpid函数</h2><pre><code>获取当前进程的pid。这个pid与ps命令里显示的进程id一致。</code></pre><h2 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a>getppid函数</h2><pre><code>获取当前进程的父进程的id。这个ppid与ps命令里显示的进程id一致。</code></pre><h3 id="子进程共享父进程的文件描述符表："><a href="#子进程共享父进程的文件描述符表：" class="headerlink" title="子进程共享父进程的文件描述符表："></a>子进程共享父进程的文件描述符表：</h3><pre><code>当父进程使用 fork 系统调用创建一个子进程时，子进程会继承父进程的文件描述符表。这意味着子进程会获得父进程打开的所有文件和 I/O 资源的文件描述符。实际上，子进程会得到父进程文件描述符表的一个副本。因此，它们并不是共享同一个文件描述符表，而是子进程拥有父进程文件描述符表的副本。然而，由于子进程和父进程的文件描述符都指向同一个文件或 I/O 资源，所以在某种程度上可以认为它们共享文件描述符。</code></pre><h3 id="“读时共享，写时拷贝”（Copy-on-Write）机制："><a href="#“读时共享，写时拷贝”（Copy-on-Write）机制：" class="headerlink" title="“读时共享，写时拷贝”（Copy-on-Write）机制："></a>“<strong>读时共享，写时拷贝</strong>”（Copy-on-Write）机制：</h3><pre><code>这是 Linux 系统在进行内存管理时所使用的一种优化技术。当父进程创建子进程时，操作系统并不会立即为子进程分配所有内存资源，而是让子进程和父进程共享相同的物理内存页。只有当父进程或子进程试图修改某个内存页时，系统才会复制该内存页，为执行写入操作的进程创建一个新的物理内存页。这样做的好处是节省内存资源，同时提高了 fork 操作的性能。</code></pre><h2 id="文件描述符表与“读时共享，写时拷贝”机制是两个不同层面的概念"><a href="#文件描述符表与“读时共享，写时拷贝”机制是两个不同层面的概念" class="headerlink" title="文件描述符表与“读时共享，写时拷贝”机制是两个不同层面的概念."></a>文件描述符表与“读时共享，写时拷贝”机制是两个不同层面的概念.</h2><blockquote><p>当父进程 fork 了一个子进程后，子进程会继承父进程的文件描述符表。实际上，子进程得到的是父进程文件描述符表的一个副本，而不是共享同一个文件描述符表。这意味着子进程和父进程的文件描述符表是相互独立的，但它们指向的文件和 I&#x2F;O 资源是相同的。</p><p>“读时共享，写时拷贝”机制是在内存管理层面进行的优化。这意味着父子进程在 fork 之后共享相同的物理内存页。只有当父进程或子进程试图修改某个内存页时，系统才会复制该内存页，为执行写入操作的进程创建一个新的物理内存页。这个过程与文件描述符表无关，涉及的是进程间内存资源的共享与复制。</p><p>总之，父子进程在 fork 之后并不共享同一个文件描述符表，而是各自拥有文件描述符表的副本。这与“读时共享，写时拷贝”机制是不同的，后者涉及的是进程间内存资源(物理内存页)的共享与复制。</p></blockquote><h2 id="这个物理内存页都记录了哪些信息呢？"><a href="#这个物理内存页都记录了哪些信息呢？" class="headerlink" title="这个物理内存页都记录了哪些信息呢？"></a>这个物理内存页都记录了哪些信息呢？</h2><blockquote><p><strong>物理内存页</strong>（Physical Memory Page）是计算机内存管理的基本单位。在操作系统中，物理内存被划分为固定大小的页，通常为 4KB、2MB 或更大。物理内存页用于存储各种类型的数据和信息，包括：</p><ul><li>程序代码：程序的可执行代码通常被加载到内存中，以便 CPU 能够直接访问和执行这些指令。</li><li>数据：程序运行时所需的各种数据，包括全局变量、静态变量等，都存储在内存中。这些数据可能在程序执行过程中被读取或修改。</li><li>堆内存：堆是一个动态内存分配区域，用于存储程序运行时动态分配的内存。堆内存的大小在程序运行过程中可能会发生变化，可以通过 malloc、calloc 等函数分配内存，通过 free 函数释放内存。</li><li>栈内存：栈是程序运行时的临时存储区，用于存储函数调用过程中的局部变量、函数参数以及返回地址等信息。栈内存由编译器自动分配和回收，具有后进先出（LIFO）的特点。</li><li>其他内核数据结构：操作系统会在内存中维护一些内核相关的数据结构，如进程控制块（PCB）、文件描述符表等，这些数据结构在操作系统中起着关键作用。</li></ul><p>总之，物理内存页存储了程序执行所需的各种信息，如代码、数据、堆内存、栈内存等。这些信息在程序运行过程中可能被多个进程共享或独占。</p></blockquote><p>————————————————</p><p><a href="https://blog.csdn.net/weixin_49503250/article/details/129500813">Linux系统调用之fork，getpid，getppid函数（进程相关函数，与G老师的对话，必看！）</a></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0/">C语言笔记 函数</category>
      
      
      <comments>http://example.com/2023/10/24/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AIX命令相关杂记</title>
      <link>http://example.com/2023/10/12/AIX%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3%E6%9D%82%E8%AE%B0/</link>
      <guid>http://example.com/2023/10/12/AIX%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3%E6%9D%82%E8%AE%B0/</guid>
      <pubDate>Thu, 12 Oct 2023 09:50:58 GMT</pubDate>
      
      <description>&lt;p&gt;以下命令比较随意，没有顺序，仅仅当作笔记使用。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>以下命令比较随意，没有顺序，仅仅当作笔记使用。</p><span id="more"></span><h2 id="1-prtconf"><a href="#1-prtconf" class="headerlink" title="1. prtconf"></a>1. prtconf</h2><ul><li>可以查看系统所有的信息 cpu 内存 硬盘等</li></ul><h2 id="2-nmon"><a href="#2-nmon" class="headerlink" title="2.nmon"></a>2.nmon</h2><p>-可以实时查看AIX信息，比topas好用老多了。</p><blockquote><p>用法：输入nmon 然后输入h会看到相关参数。<br>贼拉好用～怒赞呀～用这个命令发现了一个超级大bug。</p></blockquote>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/AIX/">AIX</category>
      
      
      <comments>http://example.com/2023/10/12/AIX%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3%E6%9D%82%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ESP32学习笔记</title>
      <link>http://example.com/2023/10/07/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>http://example.com/2023/10/07/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sat, 07 Oct 2023 09:46:33 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;1-环境搭建&quot;&gt;&lt;a href=&quot;#1-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;1. 环境搭建&quot;&gt;&lt;/a&gt;1. 环境搭建&lt;/h1&gt;&lt;p&gt;平台：MacBook Pro&lt;br&gt;软件：vscode + ESP-IDF&lt;br&gt;硬件：ESP32 WROOM-32、macbook 拓展坞、USB数据线（连接esp32和笔记本）    &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h1><p>平台：MacBook Pro<br>软件：vscode + ESP-IDF<br>硬件：ESP32 WROOM-32、macbook 拓展坞、USB数据线（连接esp32和笔记本）    </p><span id="more"></span><h2 id="1-1-下载安装vscode软件"><a href="#1-1-下载安装vscode软件" class="headerlink" title="1.1 下载安装vscode软件"></a>1.1 下载安装vscode软件</h2><p><a href="https://code.visualstudio.com/sha/download?build=stable&os=cli-darwin-arm64">Mac版本的vscode</a></p><p>下载安装的过程省略，因为我会，所以默认都会了。<br>下载完成之后，记得安装中文插件，当然英语好的老6可以忽略。<br><img src="image-12.png" alt="image12"></p><p>安装完中文插件重启之后，就会显示中文字体。</p><h2 id="1-2-安装esp-idf-插件"><a href="#1-2-安装esp-idf-插件" class="headerlink" title="1.2 安装esp-idf 插件"></a>1.2 安装esp-idf 插件</h2><p>重新打开vscode，然后在扩展中搜索espress,见下图：<br><img src="image-13.png" alt="Alt text"></p><p>安装完成后,在左侧点击刚安装好的扩展程序（乐鑫的图标），初始界面如下图<br><img src="esp1.png" alt="Alt text"></p><p>选择<code>EXPRESS</code>,然后按照下图选择并安装esp-idf的安装包，选择好之后，点击左下角的<code>install</code><br><img src="esp13.png" alt="esp"></p><p>安装中。。。视网络环境看，大概需要20分钟左右下载安装完毕；<br><img src="esp14.png" alt="esp2"></p><p>等出现下图中的日志时，说明安装成功。<br><img src="esp15.png" alt="esp3"></p><p>到此，<strong>环境搭建好了～撒欢儿～哏儿～</strong></p><h1 id="2-第一次例程下载"><a href="#2-第一次例程下载" class="headerlink" title="2. 第一次例程下载"></a>2. 第一次例程下载</h1><h2 id="2-1-hello-world-横空出世"><a href="#2-1-hello-world-横空出世" class="headerlink" title="2.1 hello_world 横空出世"></a>2.1 hello_world 横空出世</h2><p>作为程序猿（媛），学习新知识的一个案例必须是<code>hello world</code>.</p><p>先点击左右乐鑫的图标，然后点击F1，出来一个搜索框，然后输入<code>idf:show</code> ,看下图：<br><img src="image-15.png" alt="Alt text"></p><p>如果出现了下面选择路径的情况的话，直接选择自己安装的路径即可。<br><img src="image-16.png" alt="Alt text"></p><p>111111111111111<br><img src="eps20.png" alt="esp20"></p><p>选择保存的路径：<br><img src="esp21.png"><br>即可看到下图所示的工程，箭头所指即为主程序，<br><img src="esp231.png"><br><strong>重点！！！重点！！！这张图一定要记住</strong><br><img src="eps24.png"><br>按照上图的配置，我这里修改的地方如下：</p><ul><li>串口选择的是<code>/dev/cu.usbserial-0001</code></li><li>芯片类型选择的 <code>esp32</code></li><li>flash method 选择的是 <code>UART</code><br>配置好之后，点击编译，如下图所示：<br><img src="eps25.png"></li></ul><p>点击⚡️按钮将程序下载到开发板里面去，下图为下载完成之后的亚子～<br><img src="esp26.png"></p><p>如上图下载完成之后，电机那个小电视图标，就可以看到开发板打印的东西了。<br><strong>完美～～～    perfect ！！！</strong><br><img src="esp27.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/ESP32-MACOS/">ESP32 MACOS</category>
      
      
      <comments>http://example.com/2023/10/07/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>mysql面试题</title>
      <link>http://example.com/2023/09/28/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <guid>http://example.com/2023/09/28/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <pubDate>Thu, 28 Sep 2023 04:16:30 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;1-请说下你对-MySQL-架构的了解？&quot;&gt;&lt;a href=&quot;#1-请说下你对-MySQL-架构的了解？&quot; class=&quot;headerlink&quot; title=&quot;1. 请说下你对 MySQL 架构的了解？&quot;&gt;&lt;/a&gt;1. 请说下你对 MySQL 架构的了解？&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1-请说下你对-MySQL-架构的了解？"><a href="#1-请说下你对-MySQL-架构的了解？" class="headerlink" title="1. 请说下你对 MySQL 架构的了解？"></a>1. 请说下你对 MySQL 架构的了解？</h2><span id="more"></span><p><img src="image-10.png" alt="mysql架构"></p><blockquote></blockquote><pre><code>大体来说，MySQL 可以分为 Server 层和存储引擎两部分。Server 层包括：连接器、查询缓存、分析器、优化器、执行器等，涵盖了 MySQL 的大多数核心服务功能，以及所有的内置函数（如：日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图等等。存储引擎层负责：数据的存储和提取。其架构是插件式的，支持 InnoDB、MyISAM 等多个存储引擎。从 MySQL5.5.5 版本开始默认的是InnoDB，但是在建表时可以通过 engine = MyISAM 来指定存储引擎。不同存储引擎的表数据存取方式不同，支持的功能也不同。从上图中可以看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。</code></pre><h2 id="2-一条-SQL-语句在数据库框架中的执行流程？"><a href="#2-一条-SQL-语句在数据库框架中的执行流程？" class="headerlink" title="2. 一条 SQL 语句在数据库框架中的执行流程？"></a>2. 一条 SQL 语句在数据库框架中的执行流程？</h2><blockquote></blockquote><pre><code>1. 应用程序把查询 SQL 语句发送给服务器端执行；2. 查询缓存，如果查询缓存是打开的，服务器在接收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相对应的查询数据，如果存在，则直接返回给客户端。只有缓存不存在时，才会进行下面的操作；3. 查询优化处理，生成执行计划。这个阶段主要包括解析 SQL、预处理、优化 SQL 执行计划；4. MySQL 根据相应的执行计划完成整个查询；5. 将查询结果返回给客户端。详细过程可以看这篇博客https://blog.csdn.net/pcwl1206/article/details/86137408</code></pre><h2 id="3-数据库的三范式是什么？"><a href="#3-数据库的三范式是什么？" class="headerlink" title="3. 数据库的三范式是什么？"></a>3. 数据库的三范式是什么？</h2><pre><code>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项；第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性；第三范式：任何非主属性不依赖于其它非主属性。</code></pre><h2 id="4-char-和-varchar-的区别？"><a href="#4-char-和-varchar-的区别？" class="headerlink" title="4. char 和 varchar 的区别？"></a>4. char 和 varchar 的区别？</h2><pre><code>char(n) ：固定长度类型，比如：订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</code></pre><h2 id="5-varchar-10-和-varchar-20-的区别？"><a href="#5-varchar-10-和-varchar-20-的区别？" class="headerlink" title="5. varchar(10) 和 varchar(20) 的区别？"></a>5. varchar(10) 和 varchar(20) 的区别？</h2><pre><code>varchar(10) 中 10 的涵义最多存放 10 个字符，varchar(10) 和 varchar(20) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 order by col 采用 fixed_length 计算 col 长度.</code></pre><h2 id="6-谈谈你对索引的理解？"><a href="#6-谈谈你对索引的理解？" class="headerlink" title="6.谈谈你对索引的理解？"></a>6.谈谈你对索引的理解？</h2><blockquote><p>   索引的出现是为了提高数据的查询效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p></blockquote><blockquote><p>   同样索引也会带来很多负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p></blockquote><blockquote><h3 id="建立索引的原则："><a href="#建立索引的原则：" class="headerlink" title="建立索引的原则："></a>建立索引的原则：</h3><ol><li>在最频繁使用的、用以缩小查询范围的字段上建立索引；     </li><li>在频繁使用的、需要排序的字段上建立索引。</li></ol></blockquote><blockquote><h3 id="不适合建立索引的情况："><a href="#不适合建立索引的情况：" class="headerlink" title="不适合建立索引的情况："></a>不适合建立索引的情况：</h3></blockquote><blockquote><ol><li>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引；</li><li>对于一些特殊的数据类型，不宜建立索引，比如：文本字段（text）等。</li></ol></blockquote><h2 id="7-索引的底层使用的是什么数据结构？"><a href="#7-索引的底层使用的是什么数据结构？" class="headerlink" title="7. 索引的底层使用的是什么数据结构？"></a>7. 索引的底层使用的是什么数据结构？</h2><pre><code>索引的数据结构和具体存储引擎的实现有关,，在MySQL中使用较多的索引有 Hash 索引、B+树索引等。而我们经常使用的 InnoDB 存储引擎的默认索引实现为 B+ 树索引。</code></pre><h2 id="8-谈谈你对-B-树的理解？"><a href="#8-谈谈你对-B-树的理解？" class="headerlink" title="8. 谈谈你对 B+ 树的理解？"></a>8. 谈谈你对 B+ 树的理解？</h2><blockquote><ol><li>B+ 树是基于 B 树和叶子节点顺序访问指针进行实现，它具有 B 树的平衡性，并且通过顺序访问指针来提高区间查询的性能。</li><li>在 B+ 树中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。</li><li>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</li><li>插入、删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</li></ol></blockquote><h2 id="9-为什么-InnoDB-存储引擎选用-B-树而不是-B-树呢？"><a href="#9-为什么-InnoDB-存储引擎选用-B-树而不是-B-树呢？" class="headerlink" title="9. 为什么 InnoDB 存储引擎选用 B+ 树而不是 B 树呢？"></a>9. 为什么 InnoDB 存储引擎选用 B+ 树而不是 B 树呢？</h2><pre><code>用 B+ 树不用 B 树考虑的是 IO 对性能的影响，B 树的每个节点都存储数据，而 B+ 树只有叶子节点才存储数据，所以查找相同数据量的情况下，B 树的高度更高，IO 更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。</code></pre><h2 id="10-谈谈你对聚簇索引的理解？"><a href="#10-谈谈你对聚簇索引的理解？" class="headerlink" title="10.谈谈你对聚簇索引的理解？"></a>10.谈谈你对聚簇索引的理解？</h2><blockquote><p>聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。</p></blockquote><blockquote><h3 id="聚簇索引和非聚簇索引的区别："><a href="#聚簇索引和非聚簇索引的区别：" class="headerlink" title="聚簇索引和非聚簇索引的区别："></a>聚簇索引和非聚簇索引的区别：</h3><p>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p></blockquote><h2 id="11-谈你对哈希索引的理解？"><a href="#11-谈你对哈希索引的理解？" class="headerlink" title="11. 谈你对哈希索引的理解？"></a>11. 谈你对哈希索引的理解？</h2><blockquote><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性。无法用于排序与分组、只支持精确查找，无法用于部分查找和范围查找。<br>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如：快速的哈希查找。</p></blockquote><h2 id="12-谈谈你对覆盖索引的认识？"><a href="#12-谈谈你对覆盖索引的认识？" class="headerlink" title="12. 谈谈你对覆盖索引的认识？"></a>12. 谈谈你对覆盖索引的认识？</h2><blockquote><p>如果一个索引包含了满足查询语句中字段与条件的数据就叫做覆盖索引。具有以下优点：     </p><ol><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如：MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ol></blockquote><h2 id="13-索引的分类？"><a href="#13-索引的分类？" class="headerlink" title="13.索引的分类？"></a>13.索引的分类？</h2><blockquote><h3 id="从数据结构角度"><a href="#从数据结构角度" class="headerlink" title="从数据结构角度"></a>从数据结构角度</h3><ol><li>树索引 (O(log(n)))</li><li>Hash 索引</li></ol></blockquote><blockquote><h3 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h3><ol><li>聚集索引（clustered index）</li><li>非聚集索引（non-clustered index）</li></ol></blockquote><blockquote><h3 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h3><ol><li>普通索引</li><li>唯一索引</li><li>主键索引</li><li>联合索引</li><li>全文索引</li></ol></blockquote><h2 id="14-谈谈你对最左前缀原则的理解？"><a href="#14-谈谈你对最左前缀原则的理解？" class="headerlink" title="14. 谈谈你对最左前缀原则的理解？"></a>14. 谈谈你对最左前缀原则的理解？</h2><p>MySQL 使用联合索引时，需要满足最左前缀原则。下面举例对其进行说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 一个 2 列的索引 (name, age)，对 (name)、(name, age) 上建立了索引；</span><br><span class="line">2. 一个 3 列的索引 (name, age, sex)，对 (name)、(name, age)、(name, age, sex) 上建立了索引。</span><br></pre></td></tr></table></figure><ol><li><p>B+ 树的数据项是复合的数据结构，比如：(name, age, sex) 的时候，B+ 树是按照从左到右的顺序来建立搜索树的，比如：当(小明, 22, 男)这样的数据来检索的时候，B+ 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据。但当 (22, 男) 这样没有 name 的数据来的时候，B+ 树就不知道第一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。</p></li><li><p>当 (小明, 男) 这样的数据来检索时，B+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于小明的数据都找到，然后再匹配性别是男的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p></li></ol><h3 id="关于最左前缀的补充："><a href="#关于最左前缀的补充：" class="headerlink" title="关于最左前缀的补充："></a>关于最左前缀的补充：</h3><ol><li><p>最左前缀匹配原则会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如：a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立 (a, b, c, d) 顺序的索引，d 是用不到索引的。如果建立 (a, b, d, c) 的索引则都可以用到，a、b、d 的顺序可以任意调整。</p></li><li><p>&#x3D; 和 in 可以乱序，比如：a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立 (a, b ,c) 索引可以任意顺序，MySQL 的优化器会优化成索引可以识别的形式。</p></li></ol><h2 id="15-怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因"><a href="#15-怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因" class="headerlink" title="15. 怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?"></a>15. 怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?</h2><pre><code>使用 Explain 命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如：possilbe_key、key、key_len 等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。</code></pre><h2 id="16-什么情况下索引会失效？即查询不走索引？"><a href="#16-什么情况下索引会失效？即查询不走索引？" class="headerlink" title="16. 什么情况下索引会失效？即查询不走索引？"></a>16. 什么情况下索引会失效？即查询不走索引？</h2><p>下面列举几种不走索引的 SQL 语句：</p><p>1、索引列参与表达式计算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;sname&#x27;</span> <span class="keyword">FROM</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">WHERE</span> <span class="string">&#x27;age&#x27;</span> <span class="operator">+</span> <span class="number">10</span> <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>2、 函数运算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;sname&#x27;</span> <span class="keyword">FROM</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(<span class="string">&#x27;date&#x27;</span>,<span class="number">4</span>) <span class="operator">&lt;</span> <span class="number">1990</span>; </span><br></pre></td></tr></table></figure><p>3、%词语%–模糊查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;manong&#x27;</span> <span class="keyword">WHERE</span> `uname` <span class="keyword">LIKE</span> <span class="string">&#x27;码农%&#x27;</span> <span class="comment">-- 走索引 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;manong&#x27;</span> <span class="keyword">WHERE</span> `uname` <span class="keyword">LIKE</span> <span class="string">&#x27;%码农%&#x27;</span> <span class="comment">-- 不走索引 </span></span><br></pre></td></tr></table></figure><p>4、 字符串与数字比较不走索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">&#x27;a&#x27;</span> (<span class="string">&#x27;a&#x27;</span> <span class="type">char</span>(<span class="number">10</span>));</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">WHERE</span> <span class="string">&#x27;a&#x27;</span><span class="operator">=</span>&quot;1&quot; — 走索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;a&#x27;</span><span class="keyword">WHERE</span> <span class="string">&#x27;a&#x27;</span><span class="operator">=</span><span class="number">1</span> — 不走索引，同样也是使用了函数运算</span><br></pre></td></tr></table></figure><p>5、 查询条件中有 or ，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> dname<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> <span class="keyword">or</span> loc<span class="operator">=</span><span class="string">&#x27;xx&#x27;</span> <span class="keyword">or</span> deptno <span class="operator">=</span> <span class="number">45</span>;</span><br></pre></td></tr></table></figure><p>6、正则表达式不使用索引。</p><p>7、 MySQL 内部优化器会对 SQL 语句进行优化，如果优化器估计使用全表扫描要比使用索引快，则不使用索引。</p><h2 id="17-查询性能的优化方法？"><a href="#17-查询性能的优化方法？" class="headerlink" title="17. 查询性能的优化方法？"></a>17. 查询性能的优化方法？</h2><h3 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h3><ol><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ol><h3 id="减少服务器端扫描的行数"><a href="#减少服务器端扫描的行数" class="headerlink" title="减少服务器端扫描的行数"></a>减少服务器端扫描的行数</h3><ol><li>最有效的方式是使用索引来覆盖查询。</li></ol><h2 id="18-InnoDB-和-MyISAM-的比较？"><a href="#18-InnoDB-和-MyISAM-的比较？" class="headerlink" title="18. InnoDB 和 MyISAM 的比较？"></a>18. InnoDB 和 MyISAM 的比较？</h2><ol><li>事务：MyISAM不支持事务，InnoDB支持事务；</li><li>全文索引：MyISAM 支持全文索引，InnoDB 5.6 之前不支持全文索引；</li><li>关于 count()：MyISAM会直接存储总行数，InnoDB 则不会，需要按行扫描。意思就是对于 select count() from table; 如果数据量大，MyISAM 会瞬间返回，而 InnoDB 则会一行行扫描；</li><li>外键：MyISAM 不支持外键，InnoDB 支持外键；</li><li>锁：MyISAM 只支持表锁，InnoDB 可以支持行锁。</li></ol><h2 id="19-谈谈你对水平切分和垂直切分的理解？"><a href="#19-谈谈你对水平切分和垂直切分的理解？" class="headerlink" title="19.谈谈你对水平切分和垂直切分的理解？"></a>19.谈谈你对水平切分和垂直切分的理解？</h2><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>水平切分是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。例如：将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><h2 id="20-主从复制中涉及到哪三个线程？"><a href="#20-主从复制中涉及到哪三个线程？" class="headerlink" title="20. 主从复制中涉及到哪三个线程？"></a>20. 主从复制中涉及到哪三个线程？</h2><p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p><ol><li><p>binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</p></li><li><p>I&#x2F;O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Relay log）中。</p></li><li><p>SQL 线程 ：负责读取重放日志并重放其中的 SQL 语句。<br><img src="image-11.png" alt="Alt text"></p></li></ol><h2 id="21-主从同步的延迟原因及解决办法？"><a href="#21-主从同步的延迟原因及解决办法？" class="headerlink" title="21. 主从同步的延迟原因及解决办法？"></a>21. 主从同步的延迟原因及解决办法？</h2><h3 id="主从同步的延迟的原因："><a href="#主从同步的延迟的原因：" class="headerlink" title="主从同步的延迟的原因："></a>主从同步的延迟的原因：</h3><pre><code>假如一个服务器开放 Ｎ 个连接给客户端，这样有会有大并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有一个， 当某个 SQL 在从服务器上执行的时间稍长或者由于某个 SQL 要进行锁表就会导致主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。</code></pre><h3 id="主从同步延迟的解决办法："><a href="#主从同步延迟的解决办法：" class="headerlink" title="主从同步延迟的解决办法："></a>主从同步延迟的解决办法：</h3><blockquote><p>实际上主从同步延迟根本没有什么一招制敌的办法， 因为所有的 SQL 必须都要在从服务器里面执行一遍，但是主服务器如果不断的有更新操作源源不断的写入，那么一旦有延迟产生，那么延迟加重的可能性就会原来越大。当然我们可以做一些缓解的措施。</p><ol><li>我们知道因为主服务器要负责更新操作， 它对安全性的要求比从服务器高，所有有些设置可以修改，比如sync_binlog&#x3D;1，innodb_flush_log_at_trx_commit &#x3D; 1 之类的设置，而 slave 则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 或者关闭 binlog、innodb_flushlog、innodb_flush_log_at_trx_commit 也 可以设置为 0 来提高 SQL 的执行效率。</li><li>增加从服务器，这个目的还是分散读的压力， 从而降低服务器负载。</li></ol></blockquote><h2 id="22-谈谈你对数据库读写分离的理解？"><a href="#22-谈谈你对数据库读写分离的理解？" class="headerlink" title="22. 谈谈你对数据库读写分离的理解？"></a>22. 谈谈你对数据库读写分离的理解？</h2><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><h3 id="读写分离能提高性能的原因在于："><a href="#读写分离能提高性能的原因在于：" class="headerlink" title="读写分离能提高性能的原因在于："></a>读写分离能提高性能的原因在于：</h3><ol><li><p>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</p></li><li><p>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</p></li><li><p>增加冗余，提高可用性。</p></li></ol><h2 id="23-请你描述下事务的特性？"><a href="#23-请你描述下事务的特性？" class="headerlink" title="23. 请你描述下事务的特性？"></a>23. 请你描述下事务的特性？</h2><ol><li><p>原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p>一致性：执行事务前后，数据库从一个一致性状态转换到另一个一致性状态。</p></li><li><p>隔离性：并发访问数据库时，一个用户的事物不被其他事务所干扰，各并发事务之间数据库是独立的；</p></li><li><p>持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库 发生故障也不应该对其有任何影响。</p></li></ol><h2 id="24-谈谈你对事务隔离级别的理解？"><a href="#24-谈谈你对事务隔离级别的理解？" class="headerlink" title="24. 谈谈你对事务隔离级别的理解？"></a>24. 谈谈你对事务隔离级别的理解？</h2><ol><li><p>READ_UNCOMMITTED（未提交读）: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；</p></li><li><p>READ_COMMITTED（提交读）: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；</p></li><li><p>REPEATABLE_READ（可重复读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；</p></li><li><p>SERIALIZABLE（串行化）: 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p></li></ol><h2 id="25-解释下什么叫脏读、不可重复读和幻读？"><a href="#25-解释下什么叫脏读、不可重复读和幻读？" class="headerlink" title="25. 解释下什么叫脏读、不可重复读和幻读？"></a>25. 解释下什么叫脏读、不可重复读和幻读？</h2><ul><li><h2 id="脏读："><a href="#脏读：" class="headerlink" title="脏读："></a>脏读：</h2></li></ul><p>表示一个事务能够读取另一个事务中还未提交的数据。比如：某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><ul><li><h2 id="不可重复读-："><a href="#不可重复读-：" class="headerlink" title="不可重复读 ："></a>不可重复读 ：</h2></li></ul><p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果 只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题</p><p><strong>不可重复读的重点是修改</strong> :同样的条件 , 你读取过的数据 , 再次读取出来发现值不一样了</p><ul><li><h2 id="幻读："><a href="#幻读：" class="headerlink" title="幻读："></a>幻读：</h2></li></ul><p>指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><p>__幻读的重点在于新增或者删除__：同样的条件 , 第 1 次和第 2 次读出来的记录数不一样</p><h2 id="26-MySQL-默认的隔离级别是什么？"><a href="#26-MySQL-默认的隔离级别是什么？" class="headerlink" title="26. MySQL 默认的隔离级别是什么？"></a>26. MySQL 默认的隔离级别是什么？</h2><pre><code>MySQL默认采用的 REPEATABLE_READ隔离级别。Oracle 默认采用的 READ_COMMITTED 隔离级别。</code></pre><h2 id="27-谈谈你对MVCC-的了解？"><a href="#27-谈谈你对MVCC-的了解？" class="headerlink" title="27. 谈谈你对MVCC 的了解？"></a>27. 谈谈你对MVCC 的了解？</h2><h3 id="数据库并发场景："><a href="#数据库并发场景：" class="headerlink" title="数据库并发场景："></a>数据库并发场景：</h3><ol><li><p>读-读：不存在任何问题，也不需要并发控制；</p></li><li><p>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；</p></li><li><p>写-写：有线程安全问题，可能会存在更新丢失问题。</p></li></ol><p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。</p><h3 id="MVCC-可以为数据库解决以下问题："><a href="#MVCC-可以为数据库解决以下问题：" class="headerlink" title="MVCC 可以为数据库解决以下问题："></a>MVCC 可以为数据库解决以下问题：</h3><ol><li><p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；</p></li><li><p>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。</p></li></ol><h2 id="说一下-MySQL-的行锁和表锁？"><a href="#说一下-MySQL-的行锁和表锁？" class="headerlink" title="说一下 MySQL 的行锁和表锁？"></a>说一下 MySQL 的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><ul><li><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</p></li><li><p>行级锁：开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高。</p></li></ul><h2 id="29-InnoDB-存储引擎的锁的种类有哪些？"><a href="#29-InnoDB-存储引擎的锁的种类有哪些？" class="headerlink" title="29.InnoDB 存储引擎的锁的种类有哪些？"></a>29.InnoDB 存储引擎的锁的种类有哪些？</h2><ol><li><p>Record lock：单个行记录上的锁；</p></li><li><p>Gap lock：间隙锁，锁定一个范围，不包括记录本身；</p></li><li><p>Next-key lock：record+gap 锁定一个范围，包含记录本身。</p></li></ol><h2 id="30-MySQL-问题排查都有哪些手段？"><a href="#30-MySQL-问题排查都有哪些手段？" class="headerlink" title="30. MySQL 问题排查都有哪些手段？"></a>30. MySQL 问题排查都有哪些手段？</h2><ol><li><p>使用 show processlist 命令查看当前所有连接信息；</p></li><li><p>使用 Explain 命令查询 SQL 语句执行计划；</p></li><li><p>开启慢查询日志，查看慢查询的 SQL。</p></li></ol><h2 id="31-MySQL-数据库-CPU-飙升到-500-的话他怎么处理？"><a href="#31-MySQL-数据库-CPU-飙升到-500-的话他怎么处理？" class="headerlink" title="31.  MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？"></a>31.  MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？</h2><pre><code>当 CPU 飙升到 500% 时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。如果是 mysqld 造成的，通过 SHOW PROCESSLIST 查看正在运行的线程，是不是有消耗资源的 SQL 在运行，找出其中消耗高的 SQL，看看执行计划是否准确， index 是否缺失，或者是数据量太大造成。然后 kill 掉这些线程（同时观察 CPU 使用率是否下降），等进行相应的调整（比如说加索引、改 SQL、改内存参数）之后，再重新跑这些 SQL。若每个 SQL 消耗资源都不多，只是同一时间大量的 session 连进来导致 CPU 飙升，这种情况就需要分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</code></pre><h2 id="32-MySQL的redo-log，undo-log，bin-log都是干什么的"><a href="#32-MySQL的redo-log，undo-log，bin-log都是干什么的" class="headerlink" title="32. MySQL的redo log，undo log，bin log都是干什么的"></a>32. MySQL的redo log，undo log，bin log都是干什么的</h2><pre><code>redo log是InnoDB引擎特有的，只记录该引擎中表的修改记录。binlog是MySQL的Server层实现的，会记录所有引擎对数据库的修改。redo log是物理日志，记录的是在具体某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑。redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</code></pre><h3 id="以下是用户补充"><a href="#以下是用户补充" class="headerlink" title="以下是用户补充"></a>以下是用户补充</h3><pre><code>1、redolog记录修改内容（哪一页发生了什么变化），写于事务开始前，用于数据未落磁盘，但数据库挂了后的数据恢复2、binlog记录修改SQL，写于事务提交时，可用于读写分离3、undolog记录修改前记录，用于回滚和多版本并发控制</code></pre><h2 id="33-SQL-与-MySQL-有什么区别"><a href="#33-SQL-与-MySQL-有什么区别" class="headerlink" title="33. SQL 与 MySQL 有什么区别"></a>33. SQL 与 MySQL 有什么区别</h2><p>SQL 和 MySQL 是 DBMS 中最令人困惑的两个术语，二者之间存在本质上的区别。</p><ul><li>SQL 是一种 结构化查询语言，用于在数据库上执行各种操作，但 MySQL 是一个 关系数据库管理系统（RDBMS），使用 SQL 执行所有数据库操作。</li><li>SQL 用于访问，更新和操作数据库中的数据，用户使用时需要学习该语言，然后编写查询，而 MySQL 是一个软件，会为用户提供一个界面，只需单击一些按钮即可用于执行各种数据库操作。</li><li>由于 MySQL 是一个软件，所以它会定期获得各种更新，但在 SQL 中，命令总是相同的。</li></ul><h2 id="34-添加索引的原则"><a href="#34-添加索引的原则" class="headerlink" title="34. 添加索引的原则"></a>34. 添加索引的原则</h2><p>索引虽好，但也不是无限制使用的，以下为添加索引时需要遵循的几项建议性原则：</p><ul><li>在查询中很少使用 或者参考的列不要创建索引。由于这些列很少使用到，增加索引反而会降低系统的维护速度和增大空间需求。</li><li>只有很少数据值的列 也不应该增加索引。由于这些列的取值很少，区分度太低，例如人事表中的性别，在查询时，需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>定义为 text、image 和 bit 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li><li>当修改性能远远大于检索性能 时，不应该创建索引。这时因为，二者是相互矛盾的，当增加索引时，会提高检索性能，但是会降低修改性能。</li><li>定义有 外键 的数据列一定要创建索引。</li></ul><h2 id="35-有哪些事务状态"><a href="#35-有哪些事务状态" class="headerlink" title="35. 有哪些事务状态"></a>35. 有哪些事务状态</h2><ul><li>活跃状态：事务的第一个状态，任何正在执行的事务都处于此状态，所做的 更改 存储在 主内存的缓冲区 中。</li><li>部分提交状态：执行上次操作后，事务进入部分提交状态。之所以是部分提交，是因为所做的更改仍然在主内存的缓冲区中。</li><li>失败状态：如果某个检查在活动状态下失败，在活动状态或部分提交状态发生一些错误，并且事务无法进一步执行，则事务进入失败状态。</li><li>中止状态：如果任何事务已达到失败状态，则恢复管理器将数据库回滚到开始执行的原始状态。</li><li>提交状态：如果所有操作成功执行，则来自 部分提交状态 的事务进入提交状态。无法从此状态回滚，它是一个新的 一致状态。</li></ul><h2 id="36-什么是死锁？如何解决死锁？"><a href="#36-什么是死锁？如何解决死锁？" class="headerlink" title="36. 什么是死锁？如何解决死锁？"></a>36. 什么是死锁？如何解决死锁？</h2><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><h3 id="常见的解决死锁的方法"><a href="#常见的解决死锁的方法" class="headerlink" title="常见的解决死锁的方法"></a>常见的解决死锁的方法</h3><ul><li>如果不同程序并发存取多个表，尽量约定 以相同的顺序访问表，可以大大降低死锁机会；</li><li>在同一个事务中，尽可能做到 一次锁定所需要的所有资源，减少死锁产生概率；</li><li>对于非常容易产生死锁的业务部分，可以尝试使用 升级锁定颗粒度，通过 表级锁 定来减少死锁产生的概率。</li></ul><h2 id="37-什么是乐观锁和悲观锁？如何实现？"><a href="#37-什么是乐观锁和悲观锁？如何实现？" class="headerlink" title="37. 什么是乐观锁和悲观锁？如何实现？"></a>37. 什么是乐观锁和悲观锁？如何实现？</h2><p>DBMS 中的 并发控制 的任务是确保在 <strong>多个事务同时存取数据库中同一数据</strong> 时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p>__悲观锁__：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。这对于长事务来讲，可能会严重影响系统的并发处理能力。实现方式：使用数据库中的锁机制。</p><p>__乐观锁__：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁适用于 读多写少 的应用场景，这样可以提高吞吐量。实现方式：一般会使用版本号机制或 CAS 算法实现。</p><h2 id="38-什么是超键？什么是主键？"><a href="#38-什么是超键？什么是主键？" class="headerlink" title="38. 什么是超键？什么是主键？"></a>38. 什么是超键？什么是主键？</h2><p>__超 键__：在关系中，能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p>__候选键__：是最小超键，即没有冗余元素的超键。</p><p>__主 键__：数据库表中对储存数据对象予以 唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。</p><p>__外 键__：在一个表中存在的另一个表的主键称此表的外键，外键可以有重复的, 可以是空值。外键是用来和其他表建立联系用的。</p><h2 id="39-UNION-与-UNION-ALL-的区别"><a href="#39-UNION-与-UNION-ALL-的区别" class="headerlink" title="39. UNION 与 UNION ALL 的区别"></a>39. UNION 与 UNION ALL 的区别</h2><pre><code>UNION 用于把来自多个 SELECT 语句的结果组合到一个结果集合中，MySQL 会把结果集中 重复的记录删掉，而使用 UNION ALL，MySQL 会把所有的记录返回，且效率高于 UNION 。</code></pre><h2 id="40-DROP、DELETE-与-TRUNCATE-的区别"><a href="#40-DROP、DELETE-与-TRUNCATE-的区别" class="headerlink" title="40. DROP、DELETE 与 TRUNCATE 的区别"></a>40. DROP、DELETE 与 TRUNCATE 的区别</h2><p>三种都可以表示删除，其中的细微区别之处如下：</p><table><thead><tr><th></th><th>DROP</th><th>DELETE</th><th>TRUNCATE</th></tr></thead><tbody><tr><td>SQL 语句类型</td><td>DDL</td><td>DML</td><td>DDL</td></tr><tr><td>回滚</td><td>不可回滚</td><td>可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td><td>表结构还在，删除表的 全部或者一部分数据行</td><td>表结构还在，删除表中的 所有数据</td></tr><tr><td>删除速度</td><td>删除速度最快</td><td>删除速度慢，需要逐行删除</td><td>删除速度快</td></tr></tbody></table><p>因此，在不再需要一张表的时候，采用 DROP；在想删除部分数据行时候，用 DELETE；在保留表而删除所有数据的时候用 TRUNCATE。</p><h2 id="41-为什么要分库分表"><a href="#41-为什么要分库分表" class="headerlink" title="41. 为什么要分库分表"></a>41. 为什么要分库分表</h2><p>数据库中的数据量不一定是可控的，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地数据操作,例如 <strong>增删改查的开销</strong> 也会越来越大；<br>   另外，若不进行分布式部署，而一台服务器的 资源 （CPU、磁盘、内存、IO 等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。<br>所以，从 <strong>性能</strong> 和 <strong>可用性</strong> 角度考虑，会进行数据库拆分处理，具体地说，把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上，即 分库分表。</p><h2 id="42-分库分表存在哪些问题"><a href="#42-分库分表存在哪些问题" class="headerlink" title="42.  分库分表存在哪些问题"></a>42.  分库分表存在哪些问题</h2><p>__事务问题__：分库分表后，就成了分布式事务。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p><p>__跨库跨表的 JOIN 问题__：在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法 JOIN 位于不同分库的表，也无法 JOIN 分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。</p><p>__额外的数据管理负担和数据运算压力__：额外的数据管理负担，最为常见的是数据的 定位问题 和数据的 增删改查 的重复执行问题，这些都可以通过应用程序来解决，但必然会引起额外的逻辑运算。</p><h2 id="34-MySQL-读写分离的实现方案"><a href="#34-MySQL-读写分离的实现方案" class="headerlink" title="34. MySQL 读写分离的实现方案"></a>34. MySQL 读写分离的实现方案</h2><p>MySQL 读写分离的实现方式主要基于 主从复制，通过 路由的方式 使应用对数据库的写请求只在 Master 上进行，读请求在 Slave 上进行。        </p><p>具体地，有以下四种实现方案：    </p><h3 id="方案一：基于-MySQL-proxy-代理"><a href="#方案一：基于-MySQL-proxy-代理" class="headerlink" title="方案一：基于 MySQL proxy 代理"></a>方案一：基于 MySQL proxy 代理</h3><p>在应用和数据库之间增加 代理层，代理层接收应用对数据库的请求，根据不同请求类型（即是读 read 还是写 write）转发到不同的实例，在实现读写分离的同时可以实现负载均衡。MySQL 的代理最常见的是 mysql-proxy、cobar、mycat、Atlas 等。</p><h3 id="方案二：基于应用内路由"><a href="#方案二：基于应用内路由" class="headerlink" title="方案二：基于应用内路由"></a>方案二：基于应用内路由</h3><p>基于应用内路由的方式即为在应用程序中实现，针对不同的请求类型去不同的实例执行 SQL。</p><p>具体实现可基于 spring 的 aop：用 aop 来拦截 spring 项目的 dao 层方法，根据方法名称就可以判断要执行的类型，进而动态切换主从数据源。</p><h3 id="方案三：基于-MySQL-Connector-Java-的-JDBC-驱动方式"><a href="#方案三：基于-MySQL-Connector-Java-的-JDBC-驱动方式" class="headerlink" title="方案三：基于 MySQL-Connector-Java 的 JDBC 驱动方式"></a>方案三：基于 MySQL-Connector-Java 的 JDBC 驱动方式</h3><p>Java 程序通过在连接 MySQL 的 JDBC 中配置主库与从库等地址，JDBC 会自动将读请求发送给从库，将写请求发送给主库，此外， MySQL 的 JDBC 驱动还能够实现多个从库的负载均衡。</p><h3 id="方案四：基于-sharding-jdbc-的方式"><a href="#方案四：基于-sharding-jdbc-的方式" class="headerlink" title="方案四：基于 sharding-jdbc 的方式"></a>方案四：基于 sharding-jdbc 的方式</h3><p>sharding-sphere 是强大的读写分离、分表分库中间件，sharding-jdbc 是 sharding-sphere 的核心模块。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.iamshuaidi.com/mysql-interview">参考的这个网站</a></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/mysql-%E9%9D%A2%E8%AF%95%E9%A2%98/">mysql 面试题</category>
      
      
      <comments>http://example.com/2023/09/28/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
